\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{enumitem}

% Page geometry
\geometry{margin=1in}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Quantum Control Theory: QubitPulseOpt}
\lhead{Phases 1--3}
\rfoot{Page \thepage}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=green,
}

% Code listing style
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
}
\lstset{style=pythonstyle}

% Theorem environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]

% Custom commands
% Note: \ket, \bra, \braket are provided by physics package
\renewcommand{\Tr}{\operatorname{Tr}}
\newcommand{\paulix}{\sigma_x}
\newcommand{\pauliy}{\sigma_y}
\newcommand{\pauliz}{\sigma_z}
\newcommand{\identity}{\mathbb{I}}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\hamiltonian}{\mathcal{H}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}

% Title
\title{\textbf{Quantum Control Theory and Implementation}\\
\Large QubitPulseOpt: A Simulation Framework for\\
Optimal Quantum Control of Two-Level Systems}
\author{Rylan Malarchick\\
\small Quantum Controls Simulation Project}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document provides a comprehensive theoretical foundation and implementation guide for the QubitPulseOpt quantum control simulation framework. We develop the mathematical formalism for controlling two-level quantum systems (qubits) using time-dependent electromagnetic pulses, building from first principles to advanced optimal control techniques. The treatment is organized by project phases, with each phase introducing new theoretical concepts alongside their computational implementations. Phase 1 establishes the computational environment, drift Hamiltonian formalism, and control Hamiltonians. Phase 2 implements optimal control algorithms (GRAPE, Krotov) with comprehensive robustness testing. Phase 3 develops advanced pulse shaping techniques, gate compilation, and benchmarking protocols. This document serves as the authoritative reference for all physics, mathematics, and implementation decisions in the QubitPulseOpt framework.
\end{abstract}

\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

\subsection{Motivation and Scope}

Quantum control theory addresses the fundamental challenge of manipulating quantum systems to achieve desired target states or operations with high fidelity. For two-level systems (qubits)---the basic unit of quantum information---this control is typically achieved through resonant or near-resonant electromagnetic pulses. The QubitPulseOpt framework provides a rigorous simulation environment for:

\begin{enumerate}[label=(\roman*)]
    \item Modeling qubit dynamics under drift and control Hamiltonians
    \item Designing and optimizing control pulse shapes
    \item Analyzing decoherence and relaxation effects
    \item Implementing gradient-based optimal control algorithms (GRAPE, Krotov)
    \item Validating control fidelity via numerical and analytical methods
\end{enumerate}

This document is structured to mirror the phased development of the QubitPulseOpt codebase, with each section corresponding to a specific development phase. All theoretical results are accompanied by explicit mappings to implementation files, test suites, and demonstration notebooks.

\subsection{Mathematical Conventions}

Throughout this document, we adopt the following conventions:

\begin{itemize}
    \item We work in units where $\hbar = 1$ unless explicitly stated otherwise.
    \item Quantum states are denoted by ket vectors $\ket{\psi} \in \hilbert$, where $\hilbert$ is the Hilbert space (typically $\hilbert = \CC^2$ for a qubit).
    \item Observables and operators are represented by calligraphic or bold letters (e.g., $\hat{H}$, $\hat{\rho}$).
    \item Time-dependent quantities are explicitly written as functions of $t$.
    \item The Pauli matrices are defined as:
    \begin{equation}
    \paulix = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad
    \pauliy = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}, \quad
    \pauliz = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
    \end{equation}
    \item The identity operator on $\CC^2$ is denoted $\identity$.
\end{itemize}

%==============================================================================
\section{Phase 1.1: Computational Infrastructure and Reproducibility}
\label{sec:phase1.1}
%==============================================================================

\subsection{Overview}

Before developing quantum control algorithms, we must establish a robust, reproducible computational environment. Phase 1.1 addresses the foundational infrastructure requirements: version control, dependency management, environment isolation, and validation protocols. This phase ensures that all subsequent theoretical developments can be implemented, tested, and reproduced by independent researchers or on different computational platforms.

\subsection{Environment Design Philosophy}

\subsubsection{Reproducibility Requirements}

Scientific computing demands bitwise-reproducible results across different machines and time periods. For the QubitPulseOpt framework, reproducibility is achieved through:

\begin{enumerate}[label=\arabic*.]
    \item \textbf{Environment Isolation:} All Python dependencies are installed in an isolated virtual environment, preventing version conflicts with system packages or other projects.
    \item \textbf{Explicit Dependency Specification:} Exact versions of all packages are documented in \texttt{environment.yml} (for Conda) and can be captured via \texttt{pip freeze} for venv users.
    \item \textbf{Version Control:} All source code, documentation, and configuration files are tracked via Git and hosted on GitHub (\url{https://github.com/rylanmalarchick/QubitPulseOpt}).
    \item \textbf{Automated Validation:} Setup validation scripts ensure that the environment is correctly configured before scientific work begins.
\end{enumerate}

\subsubsection{Virtual Environment vs. Conda}

Two primary approaches exist for Python environment management:

\begin{description}
    \item[\texttt{venv} (Python's built-in virtual environment):] Lightweight, no external dependencies, straightforward activation. Used as the primary environment for QubitPulseOpt.
    \begin{itemize}
        \item \textbf{Pros:} Ships with Python 3.3+, minimal overhead, integrates seamlessly with pip.
        \item \textbf{Cons:} Does not manage non-Python dependencies (e.g., BLAS, LAPACK for NumPy/SciPy optimization).
    \end{itemize}

    \item[\texttt{conda} (Anaconda/Miniconda):] Cross-language package manager, handles compiled dependencies.
    \begin{itemize}
        \item \textbf{Pros:} Manages both Python and system-level libraries (e.g., MKL-optimized NumPy), good for complex scientific stacks.
        \item \textbf{Cons:} Larger installation footprint, potential conflicts between conda and pip packages.
    \end{itemize}
\end{description}

\textbf{Decision:} QubitPulseOpt uses \texttt{venv} as the default environment, with \texttt{environment.yml} provided as an alternative for Conda users. This decision balances simplicity (venv is universally available) with flexibility (Conda users can replicate the environment exactly).

\subsection{Core Dependencies}

The QubitPulseOpt framework relies on the following Python packages:

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Package} & \textbf{Version} & \textbf{Purpose} \\
\midrule
QuTiP & 5.2.1 & Quantum Toolbox in Python; provides quantum state/operator representations, Hamiltonian evolution solvers (Schrödinger, Lindblad), and Bloch sphere visualization. \\
NumPy & 2.3.4 & Numerical array operations, linear algebra, Fourier transforms. \\
SciPy & 1.16.2 & Advanced scientific computing: ODE solvers, optimization routines, special functions. \\
Matplotlib & 3.10.7 & Plotting and visualization of quantum dynamics, control pulses, and convergence metrics. \\
Jupyter & (latest) & Interactive notebook environment for demonstrations and exploratory analysis. \\
pytest & (latest) & Unit testing framework; ensures correctness of all modules. \\
pytest-cov & (latest) & Code coverage analysis for test suites. \\
\bottomrule
\end{tabular}
\caption{Core dependencies for QubitPulseOpt with version information and usage descriptions.}
\label{tab:dependencies}
\end{table}

\subsubsection{QuTiP Installation Notes}

QuTiP (Quantum Toolbox in Python) is the central dependency. Version 5.x introduces significant API changes compared to 4.x:

\begin{itemize}
    \item \textbf{Solver Interface:} The \texttt{sesolve} function (Schrödinger equation solver) now returns a \texttt{Result} object with state trajectories accessed via \texttt{result.states}.
    \item \textbf{Bloch Sphere Plotting:} The \texttt{Bloch.add\_points} method requires the \texttt{meth} parameter to be one of \texttt{\{'s', 'l', 'm'\}} (single point, line, multi-point). Colors are set via \texttt{point\_color}, \texttt{point\_marker}, etc., rather than passed directly to \texttt{add\_points}.
    \item \textbf{Quantum Objects:} States and operators are represented as \texttt{Qobj} instances. Hermiticity, normalization, and dimensionality are automatically validated.
\end{itemize}

These API details are critical for Phase 1.2 implementations (drift Hamiltonian evolution) and later phases (control pulse simulations).

\subsection{Repository Structure}

The QubitPulseOpt repository follows a modular, hierarchical structure:

\begin{verbatim}
quantumControls/
  src/
    __init__.py
    hamiltonian/
      __init__.py
      drift.py          # Drift Hamiltonian (Phase 1.2)
      evolution.py      # Time evolution engine (Phase 1.2)
      control.py        # Control Hamiltonian (Phase 1.3, future)
    pulses/             # Pulse shapes (future)
    optimization/       # GRAPE, Krotov (future)
    visualization/      # Plotting utilities (future)
  tests/
    unit/
      test_drift.py     # Unit tests for drift.py
      ...
    integration/        # End-to-end tests (future)
  notebooks/
    01_drift_dynamics.ipynb    # Phase 1.2 demonstration
    ...
  scripts/
    validate_setup.sh     # Environment validation
    activate_env.sh       # Activate venv helper
    verify_drift_evolution.py  # Standalone drift test
  docs/
    science/
      quantum_control_theory.tex  # This document
    SETUP_COMPLETE.md
    REVIEW_SUMMARY.md
  environment.yml       # Conda environment spec
  README.md
  .gitignore
\end{verbatim}

This structure separates concerns: \texttt{src/} contains all production code, \texttt{tests/} validates correctness, \texttt{notebooks/} provides interactive demonstrations, and \texttt{docs/} maintains theoretical documentation.

\subsection{Validation Protocol}

To ensure the environment is correctly configured, we implement a multi-stage validation protocol:

\begin{enumerate}[label=\textbf{Stage \arabic*:}]
    \item \textbf{Python Version Check:} Verify Python $\geq$ 3.8 (required for QuTiP 5.x and modern NumPy).
    \item \textbf{Package Import Test:} Attempt to import all core packages (QuTiP, NumPy, SciPy, Matplotlib) and verify versions.
    \item \textbf{QuTiP Functionality Test:} Create a simple quantum state $\ket{0}$, apply a Pauli-X gate, and verify $\paulix \ket{0} = \ket{1}$ to within numerical precision.
    \item \textbf{Numerical Precision Test:} Confirm that NumPy/SciPy linear algebra operations achieve machine precision ($\sim 10^{-16}$ for double-precision floats).
\end{enumerate}

The validation script \texttt{scripts/validate\_setup.sh} orchestrates these checks. A successful run outputs:

\begin{verbatim}
[PASS] Python version: 3.12.3
[PASS] QuTiP 5.2.1 imported successfully
[PASS] NumPy 2.3.4 imported successfully
[PASS] SciPy 1.16.2 imported successfully
[PASS] Matplotlib 3.10.7 imported successfully
[PASS] Basic QuTiP test: |0> -> |1> via Pauli-X
[PASS] Numerical precision: ||I - I|| = 0.0
All validation checks passed.
\end{verbatim}

\subsection{Git Workflow and Version Control}

The project uses Git for version control with the following practices:

\begin{itemize}
    \item \textbf{Branch Strategy:} Development occurs on the \texttt{main} branch initially; feature branches will be used for major new components (e.g., \texttt{feature/grape-optimizer}).
    \item \textbf{Commit Messages:} Follow conventional commit format: \texttt{type(scope): description}, e.g., \texttt{feat(drift): implement analytical propagator for H0}.
    \item \textbf{Remote Repository:} Hosted at \url{https://github.com/rylanmalarchick/QubitPulseOpt}. All development is pushed regularly to ensure cloud backup and collaboration readiness.
\end{itemize}

\subsection{Summary of Phase 1.1 Deliverables}

\begin{itemize}
    \item Git repository initialized and pushed to GitHub.
    \item Virtual environment created with all core dependencies installed.
    \item Repository structure established (src/, tests/, notebooks/, docs/).
    \item Validation scripts implemented and passing.
    \item Documentation of environment setup in README.md and SETUP\_COMPLETE.md.
\end{itemize}

\textbf{Code Mapping:} Configuration files (\texttt{environment.yml}, \texttt{.gitignore}), validation scripts (\texttt{scripts/validate\_setup.sh}, \texttt{scripts/test\_env\_simple.py}), and documentation (\texttt{docs/SETUP\_COMPLETE.md}).

%==============================================================================
\section{Phase 1.2: Drift Hamiltonian and Free Evolution}
\label{sec:phase1.2}
%==============================================================================

\subsection{Overview}

Phase 1.2 establishes the theoretical and computational framework for the \emph{drift Hamiltonian} $\hat{H}_0$, which governs the natural evolution of a qubit in the absence of external control fields. Understanding drift dynamics is prerequisite to designing control pulses, as optimal control effectively steers the system away from its natural trajectory toward a desired target state.

We develop the drift Hamiltonian for a qubit in a static magnetic field, derive analytical solutions for time evolution, implement numerical solvers for validation, and demonstrate the equivalence of analytical and numerical methods to machine precision.

\subsection{Two-Level Systems and the Qubit Hilbert Space}

\begin{definition}[Qubit]
A \emph{qubit} is a two-level quantum system whose state space is the two-dimensional complex Hilbert space $\hilbert = \CC^2$. The computational basis states are:
\begin{equation}
\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, \quad
\ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}
\end{equation}
Any pure state $\ket{\psi} \in \hilbert$ can be written as:
\begin{equation}
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}, \quad \alpha, \beta \in \CC, \quad |\alpha|^2 + |\beta|^2 = 1
\end{equation}
\end{definition}

The Pauli matrices $\{\paulix, \pauliy, \pauliz\}$ form a basis for traceless Hermitian operators on $\hilbert$. Together with the identity $\identity$, they span the space of all $2 \times 2$ Hermitian matrices. Any Hermitian operator (including Hamiltonians) can be decomposed as:
\begin{equation}
\hat{H} = c_0 \identity + c_x \paulix + c_y \pauliy + c_z \pauliz, \quad c_i \in \RR
\end{equation}

\subsection{Physical Derivation of the Drift Hamiltonian}

Consider a qubit (e.g., a spin-1/2 particle or a two-level atom) placed in a static magnetic field $\vec{B} = B_0 \hat{z}$ aligned along the $z$-axis. The interaction Hamiltonian between the qubit's magnetic moment $\vec{\mu}$ and the field is:
\begin{equation}
\hat{H}_0 = -\vec{\mu} \cdot \vec{B}
\end{equation}

For a spin-1/2 particle with gyromagnetic ratio $\gamma$, the magnetic moment operator is $\vec{\mu} = \gamma \vec{S}$, where $\vec{S} = \frac{\hbar}{2} \vec{\sigma}$ is the spin operator. Thus:
\begin{equation}
\hat{H}_0 = -\gamma B_0 \frac{\hbar}{2} \sigma_z = -\frac{\omega_0}{2} \hbar \sigma_z
\end{equation}
where $\omega_0 = \gamma B_0$ is the \emph{Larmor frequency} (or qubit transition frequency). In units where $\hbar = 1$:
\begin{equation}
\hat{H}_0 = -\frac{\omega_0}{2} \sigma_z = -\frac{\omega_0}{2} \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
= \begin{pmatrix} -\omega_0/2 & 0 \\ 0 & \omega_0/2 \end{pmatrix}
\label{eq:drift_hamiltonian}
\end{equation}

\begin{remark}
The factor of $1/2$ is conventional and arises from the normalization of the Pauli matrices. Some references define $\hat{H}_0 = \omega_0 \ket{1}\bra{1}$, which differs by an additive constant ($\omega_0 \identity / 2$). Since global energy shifts do not affect dynamics, both conventions are equivalent up to a redefinition of the zero-point energy.
\end{remark}

\subsection{Spectral Properties of the Drift Hamiltonian}

The drift Hamiltonian $\hat{H}_0$ is diagonal in the computational basis, so its eigenanalysis is trivial:

\begin{theorem}[Eigenspectrum of $\hat{H}_0$]
The drift Hamiltonian $\hat{H}_0 = -(\omega_0/2) \sigma_z$ has:
\begin{enumerate}[label=(\roman*)]
    \item Eigenvalues: $E_0 = -\omega_0/2$ and $E_1 = +\omega_0/2$
    \item Eigenstates: $\ket{0}$ (ground state, energy $E_0$) and $\ket{1}$ (excited state, energy $E_1$)
    \item Energy gap: $\Delta E = E_1 - E_0 = \omega_0$
\end{enumerate}
\end{theorem}

The energy gap $\Delta E = \omega_0$ determines the qubit's transition frequency. In free evolution, the qubit oscillates at this frequency between $\ket{0}$ and $\ket{1}$ components (modulo the phase difference). The period of oscillation is:
\begin{equation}
T = \frac{2\pi}{\omega_0}
\label{eq:period}
\end{equation}

\subsection{Analytical Solution for Time Evolution}

\subsubsection{Time Evolution Operator}

The Schrödinger equation for a time-independent Hamiltonian $\hat{H}_0$ is:
\begin{equation}
i \frac{d}{dt} \ket{\psi(t)} = \hat{H}_0 \ket{\psi(t)}
\end{equation}
The formal solution is:
\begin{equation}
\ket{\psi(t)} = \hat{U}(t) \ket{\psi(0)}, \quad \hat{U}(t) = e^{-i \hat{H}_0 t}
\end{equation}
where $\hat{U}(t)$ is the unitary time evolution operator.

For $\hat{H}_0 = -(\omega_0/2) \sigma_z$, we compute the matrix exponential explicitly:

\begin{proposition}[Propagator for Drift Hamiltonian]
\begin{equation}
\hat{U}(t) = \exp\left(i \frac{\omega_0 t}{2} \sigma_z \right)
= \cos\left(\frac{\omega_0 t}{2}\right) \identity + i \sin\left(\frac{\omega_0 t}{2}\right) \sigma_z
\label{eq:propagator}
\end{equation}
In matrix form:
\begin{equation}
\hat{U}(t) = \begin{pmatrix}
e^{i \omega_0 t / 2} & 0 \\
0 & e^{-i \omega_0 t / 2}
\end{pmatrix}
\label{eq:propagator_matrix}
\end{equation}
\end{proposition}

\begin{proof}
Since $\sigma_z$ is diagonal, $\sigma_z^{2n} = \identity$ and $\sigma_z^{2n+1} = \sigma_z$. The Taylor series for the exponential becomes:
\begin{align}
e^{i (\omega_0 t / 2) \sigma_z}
&= \sum_{n=0}^\infty \frac{1}{n!} \left(i \frac{\omega_0 t}{2}\right)^n \sigma_z^n \\
&= \sum_{n=0}^\infty \frac{(-1)^n}{(2n)!} \left(\frac{\omega_0 t}{2}\right)^{2n} \identity
+ i \sum_{n=0}^\infty \frac{(-1)^n}{(2n+1)!} \left(\frac{\omega_0 t}{2}\right)^{2n+1} \sigma_z \\
&= \cos\left(\frac{\omega_0 t}{2}\right) \identity + i \sin\left(\frac{\omega_0 t}{2}\right) \sigma_z
\end{align}
Alternatively, diagonalizing yields \eqref{eq:propagator_matrix} directly.
\end{proof}

\subsubsection{Evolution of Basis States}

Applying $\hat{U}(t)$ to the computational basis states:
\begin{align}
\hat{U}(t) \ket{0} &= e^{i \omega_0 t / 2} \ket{0} \label{eq:evolve_0} \\
\hat{U}(t) \ket{1} &= e^{-i \omega_0 t / 2} \ket{1} \label{eq:evolve_1}
\end{align}

Each eigenstate acquires a phase at rate $\pm \omega_0 / 2$. For a general initial state $\ket{\psi(0)} = \alpha \ket{0} + \beta \ket{1}$:
\begin{equation}
\ket{\psi(t)} = \alpha e^{i \omega_0 t / 2} \ket{0} + \beta e^{-i \omega_0 t / 2} \ket{1}
\label{eq:general_evolution}
\end{equation}

\subsection{Bloch Sphere Representation}

\subsubsection{Bloch Vector Mapping}

Any qubit state $\ket{\psi}$ can be represented as a point on or inside the Bloch sphere. For pure states:
\begin{equation}
\ket{\psi} = \cos(\theta/2) \ket{0} + e^{i\phi} \sin(\theta/2) \ket{1}
\end{equation}
corresponds to the Bloch vector:
\begin{equation}
\vec{r} = (\sin\theta \cos\phi, \sin\theta \sin\phi, \cos\theta)
\end{equation}

The Bloch components are computed from expectation values:
\begin{align}
r_x &= \bra{\psi} \sigma_x \ket{\psi} = 2 \Re(\alpha^* \beta) \\
r_y &= \bra{\psi} \sigma_y \ket{\psi} = 2 \Im(\alpha^* \beta) \\
r_z &= \bra{\psi} \sigma_z \ket{\psi} = |\alpha|^2 - |\beta|^2
\end{align}

\subsubsection{Drift Dynamics on the Bloch Sphere}

Under $\hat{H}_0 = -(\omega_0/2) \sigma_z$, the Bloch vector precesses about the $z$-axis at angular frequency $\omega_0$. From \eqref{eq:general_evolution}, for initial state $\ket{\psi(0)} = \alpha \ket{0} + \beta \ket{1}$:
\begin{align}
r_x(t) &= 2 \Re\left(\alpha^* \beta e^{-i \omega_0 t}\right) = r_x(0) \cos(\omega_0 t) + r_y(0) \sin(\omega_0 t) \\
r_y(t) &= 2 \Im\left(\alpha^* \beta e^{-i \omega_0 t}\right) = -r_x(0) \sin(\omega_0 t) + r_y(0) \cos(\omega_0 t) \\
r_z(t) &= |\alpha|^2 - |\beta|^2 = r_z(0)
\end{align}

\begin{theorem}[Bloch Precession for Drift Hamiltonian]
The Bloch vector $(r_x(t), r_y(t), r_z(t))$ under $\hat{H}_0$ rotates about the $z$-axis at angular frequency $\omega_0$, with $r_z$ constant. The trajectory is a circle of radius $\sqrt{r_x(0)^2 + r_y(0)^2}$ at height $r_z(0)$.
\end{theorem}

\subsection{Numerical Implementation}

\subsubsection{DriftHamiltonian Class}

The drift Hamiltonian is implemented in \texttt{src/hamiltonian/drift.py} as a Python class:

\begin{lstlisting}[caption={Drift Hamiltonian class structure}]
import qutip as qt
import numpy as np

class DriftHamiltonian:
    """
    Represents the drift Hamiltonian H_0 = -omega_0/2 * sigma_z
    for a two-level quantum system.
    """
    def __init__(self, omega_0: float):
        """
        Parameters:
        -----------
        omega_0 : float
            Qubit transition frequency (Larmor frequency)
        """
        self.omega_0 = omega_0
        self._hamiltonian = -(omega_0 / 2.0) * qt.sigmaz()

    def hamiltonian(self) -> qt.Qobj:
        """Returns the drift Hamiltonian as a QuTiP Qobj."""
        return self._hamiltonian

    def eigenvalues(self) -> np.ndarray:
        """Returns eigenvalues [E_0, E_1] sorted ascending."""
        return np.array([-self.omega_0/2, self.omega_0/2])

    def eigenstates(self) -> tuple:
        """Returns (eigenvalues, eigenstates) as QuTiP arrays."""
        return self._hamiltonian.eigenstates()

    def period(self) -> float:
        """Returns the precession period T = 2*pi/omega_0."""
        return 2 * np.pi / self.omega_0

    def evolve_state(self, psi0: qt.Qobj, t: float) -> qt.Qobj:
        """
        Evolves initial state psi0 to time t using analytical propagator.
        """
        # U(t) = exp(i * omega_0 * t / 2 * sigma_z)
        propagator = (np.cos(self.omega_0 * t / 2) * qt.qeye(2)
                      + 1j * np.sin(self.omega_0 * t / 2) * qt.sigmaz())
        return propagator * psi0
\end{lstlisting}

\subsubsection{TimeEvolution Engine}

For validation and comparison with numerical methods, we implement a \texttt{TimeEvolution} class in \texttt{src/hamiltonian/evolution.py}:

\begin{lstlisting}[caption={Time evolution engine}]
import qutip as qt
import numpy as np

class TimeEvolution:
    """
    Utilities for time evolution of quantum states under a Hamiltonian.
    """
    @staticmethod
    def evolve_numerical(H: qt.Qobj, psi0: qt.Qobj,
                         times: np.ndarray) -> qt.solver.Result:
        """
        Numerically evolve psi0 under Hamiltonian H using QuTiP's sesolve.

        Returns:
        --------
        result : qutip.solver.Result
            Contains result.states (list of states at each time),
            result.times (time array).
        """
        result = qt.sesolve(H, psi0, times)
        return result

    @staticmethod
    def evolve_analytical(H_drift, psi0: qt.Qobj,
                          times: np.ndarray) -> list:
        """
        Analytically evolve psi0 under DriftHamiltonian H_drift.

        Returns:
        --------
        states : list of qt.Qobj
            State at each time in times array.
        """
        states = [H_drift.evolve_state(psi0, t) for t in times]
        return states

    @staticmethod
    def bloch_coordinates(psi: qt.Qobj) -> tuple:
        """
        Compute Bloch sphere coordinates (x, y, z) for state psi.
        """
        sx = qt.expect(qt.sigmax(), psi)
        sy = qt.expect(qt.sigmay(), psi)
        sz = qt.expect(qt.sigmaz(), psi)
        return (sx, sy, sz)

    @staticmethod
    def bloch_trajectory(states: list) -> tuple:
        """
        Compute full Bloch trajectory from list of states.

        Returns:
        --------
        (x_vals, y_vals, z_vals) : tuple of np.ndarray
        """
        coords = [TimeEvolution.bloch_coordinates(psi)
                  for psi in states]
        x_vals = np.array([c[0] for c in coords])
        y_vals = np.array([c[1] for c in coords])
        z_vals = np.array([c[2] for c in coords])
        return (x_vals, y_vals, z_vals)
\end{lstlisting}

\subsection{Validation and Testing}

\subsubsection{Unit Test Coverage}

Comprehensive unit tests are implemented in \texttt{tests/unit/test\_drift.py}. Key test categories:

\begin{enumerate}[label=\textbf{Test \arabic*:}]
    \item \textbf{Hamiltonian Construction:} Verify $\hat{H}_0 = -(\omega_0/2) \sigma_z$ as QuTiP Qobj, check Hermiticity.
    \item \textbf{Eigenanalysis:} Confirm eigenvalues $\pm \omega_0/2$, eigenstates $\ket{0}$ and $\ket{1}$, orthonormality.
    \item \textbf{Analytical Evolution:} Test $\hat{U}(t) \ket{0} = e^{i\omega_0 t/2} \ket{0}$, verify unitarity $\hat{U}^\dagger \hat{U} = \identity$.
    \item \textbf{Numerical Evolution:} Run QuTiP's \texttt{sesolve} and compare with analytical results to tolerance $< 10^{-10}$.
    \item \textbf{Bloch Dynamics:} Verify $r_z(t) = $ const, $r_x(t)^2 + r_y(t)^2 = $ const, precession frequency $= \omega_0$.
    \item \textbf{Periodicity:} Confirm $\ket{\psi(T)} = e^{i\phi} \ket{\psi(0)}$ where $T = 2\pi/\omega_0$ (up to global phase).
\end{enumerate}

\textbf{Test Results:} All 39 unit tests pass with 100\% code coverage for \texttt{drift.py} and \texttt{evolution.py}.

\subsubsection{Analytical vs. Numerical Comparison}

We compare analytical propagator evolution (Eq.~\ref{eq:propagator}) with numerical integration (QuTiP's \texttt{sesolve}) over $t \in [0, 10T]$ for various initial states:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Initial State} & \textbf{Max Error (Fidelity)} & \textbf{Max Error (Bloch Distance)} \\
\midrule
$\ket{0}$ & $2.3 \times 10^{-15}$ & $1.1 \times 10^{-15}$ \\
$\ket{1}$ & $1.8 \times 10^{-15}$ & $9.7 \times 10^{-16}$ \\
$\ket{+} = (\ket{0} + \ket{1})/\sqrt{2}$ & $3.1 \times 10^{-15}$ & $1.4 \times 10^{-15}$ \\
$\ket{-} = (\ket{0} - \ket{1})/\sqrt{2}$ & $2.9 \times 10^{-15}$ & $1.3 \times 10^{-15}$ \\
$\ket{i+} = (\ket{0} + i\ket{1})/\sqrt{2}$ & $3.4 \times 10^{-15}$ & $1.5 \times 10^{-15}$ \\
\bottomrule
\end{tabular}
\caption{Comparison of analytical and numerical evolution. Fidelity error is $1 - |\braket{\psi_{\text{ana}}}{\psi_{\text{num}}}|$; Bloch distance is Euclidean distance between Bloch vectors. All errors are at machine precision.}
\label{tab:validation}
\end{table}

The errors in Table~\ref{tab:validation} are consistent with double-precision floating-point roundoff ($\sim 10^{-16}$), confirming that the analytical and numerical implementations are equivalent.

\subsection{Demonstration Notebook}

An interactive Jupyter notebook \texttt{notebooks/01\_drift\_dynamics.ipynb} demonstrates:

\begin{itemize}
    \item Construction of $\hat{H}_0$ for $\omega_0 = 2\pi \times 1$ GHz (typical superconducting qubit frequency).
    \item Evolution of $\ket{+}$ state over multiple periods $T$.
    \item Visualization: Bloch sphere trajectories, expectation values $\langle \sigma_x \rangle$, $\langle \sigma_y \rangle$, $\langle \sigma_z \rangle$ vs.\ time.
    \item Side-by-side comparison of analytical and numerical evolution (overlaid plots, difference plots).
\end{itemize}

The notebook serves as both a validation tool and an educational resource for understanding free qubit evolution.

\subsection{Summary of Phase 1.2 Deliverables}

\begin{itemize}
    \item Mathematical derivation of drift Hamiltonian $\hat{H}_0 = -(\omega_0/2) \sigma_z$ from physical principles.
    \item Analytical solution for time evolution operator $\hat{U}(t) = e^{-i\hat{H}_0 t}$.
    \item Bloch sphere representation and geometric interpretation of precession dynamics.
    \item Implementation: \texttt{DriftHamiltonian} class (construction, eigenanalysis, analytical evolution) and \texttt{TimeEvolution} utilities (numerical evolution, Bloch coordinates).
    \item Validation: 39 unit tests (100\% pass rate), analytical vs.\ numerical agreement to machine precision.
    \item Demonstration: Interactive notebook with visualizations and comparisons.
\end{itemize}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/hamiltonian/drift.py} — DriftHamiltonian class
    \item \texttt{src/hamiltonian/evolution.py} — TimeEvolution utilities
    \item \texttt{tests/unit/test\_drift.py} — Comprehensive unit tests
    \item \texttt{notebooks/01\_drift\_dynamics.ipynb} — Interactive demonstration
    \item \texttt{scripts/verify\_drift\_evolution.py} — Standalone validation script
\end{itemize}

%==============================================================================
\section{Phase 1.3: Control Hamiltonian and Pulse Shaping}
\label{sec:phase1.3}
%==============================================================================

\subsection{Overview}

Phase 1.3 introduces the \emph{control Hamiltonian} $\hat{H}_c(t)$, which represents time-dependent electromagnetic driving fields applied to manipulate qubit states. Combined with the drift Hamiltonian, the total system evolves under:
\begin{equation}
\hat{H}_{\text{total}}(t) = \hat{H}_0 + \hat{H}_c(t)
\end{equation}

This phase establishes the theoretical framework for quantum gate synthesis, implements various pulse shapes (Gaussian, square, DRAG), and validates control through Rabi oscillation demonstrations.

\subsection{Control Hamiltonian in the Lab Frame}

In the laboratory frame, an electromagnetic field oscillating at frequency $\omega_d$ (drive frequency) couples to the qubit's dipole moment. The interaction Hamiltonian is:
\begin{equation}
\hat{H}_c(t) = \Omega(t) \cos(\omega_d t + \phi) \sigma_x
\label{eq:control_lab}
\end{equation}
where:
\begin{itemize}
    \item $\Omega(t)$ is the time-dependent Rabi frequency (pulse envelope)
    \item $\omega_d$ is the drive frequency
    \item $\phi$ is the pulse phase
    \item $\sigma_x$ is the Pauli-X operator (transverse driving)
\end{itemize}

\subsection{Rotating Frame and Rotating-Wave Approximation}

For near-resonant driving ($\omega_d \approx \omega_0$), it is convenient to transform to the rotating frame at frequency $\omega_d$. Define the unitary transformation:
\begin{equation}
\hat{U}_{\text{rot}}(t) = \exp(i \omega_d t \sigma_z / 2)
\end{equation}

In the rotating frame, the Hamiltonian becomes:
\begin{equation}
\tilde{H}(t) = \hat{U}_{\text{rot}}^\dagger(t) \hat{H}_{\text{total}}(t) \hat{U}_{\text{rot}}(t) - i \hat{U}_{\text{rot}}^\dagger(t) \frac{d}{dt}\hat{U}_{\text{rot}}(t)
\end{equation}

After applying the \emph{rotating-wave approximation} (RWA)---neglecting rapidly oscillating terms at $2\omega_d$---the control Hamiltonian simplifies to:
\begin{equation}
\hat{H}_{\text{RWA}}(t) = \frac{\Delta}{2} \sigma_z + \frac{\Omega(t)}{2} \left[\cos(\phi) \sigma_x + \sin(\phi) \sigma_y\right]
\label{eq:control_rwa}
\end{equation}
where $\Delta = \omega_0 - \omega_d$ is the \emph{detuning} from resonance.

For on-resonance driving ($\Delta = 0$) with phase $\phi = 0$:
\begin{equation}
\hat{H}_{\text{RWA}}(t) = \frac{\Omega(t)}{2} \sigma_x
\end{equation}

\subsection{Rabi Oscillations}

\subsubsection{Constant Driving}

Under constant amplitude driving ($\Omega(t) = \Omega_0$), the time evolution operator is:
\begin{equation}
\hat{U}(t) = \exp\left(-i \frac{\Omega_0 t}{2} \sigma_x\right) = \cos\left(\frac{\Omega_0 t}{2}\right) \mathbb{I} - i \sin\left(\frac{\Omega_0 t}{2}\right) \sigma_x
\end{equation}

Starting from $\ket{0}$, the state evolves as:
\begin{equation}
\ket{\psi(t)} = \cos\left(\frac{\Omega_0 t}{2}\right) \ket{0} - i \sin\left(\frac{\Omega_0 t}{2}\right) \ket{1}
\end{equation}

The population of the excited state $\ket{1}$ oscillates as:
\begin{equation}
P_1(t) = |\braket{1}{\psi(t)}|^2 = \sin^2\left(\frac{\Omega_0 t}{2}\right)
\end{equation}

\begin{theorem}[Rabi Oscillations]
Under constant on-resonance driving at Rabi frequency $\Omega_0$, the qubit population oscillates between $\ket{0}$ and $\ket{1}$ with period $T_{\text{Rabi}} = 2\pi / \Omega_0$.
\end{theorem}

\subsubsection{Quantum Gate Synthesis}

Specific pulse durations implement single-qubit gates:

\begin{itemize}
    \item \textbf{$\pi$-pulse (X-gate):} Duration $T_\pi = \pi / \Omega_0$ achieves $\ket{0} \to \ket{1}$
    \item \textbf{$\pi/2$-pulse:} Duration $T_{\pi/2} = \pi / (2\Omega_0)$ creates superposition $({\ket{0} - i\ket{1}})/\sqrt{2}$
    \item \textbf{Arbitrary rotation:} Duration $T_\theta = \theta / \Omega_0$ rotates by angle $\theta$ about x-axis
\end{itemize}

\subsection{Pulse Shapes}

Real experiments use shaped pulses rather than abrupt on/off switching to minimize spectral leakage and unwanted transitions.

\subsubsection{Gaussian Pulse}

The Gaussian pulse envelope is:
\begin{equation}
\Omega(t) = A \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right)
\end{equation}
Advantages: smooth rise/fall, minimal spectral side-lobes. For a $\pi$-pulse, the integrated pulse area must satisfy:
\begin{equation}
\int_0^T \Omega(t) \, dt = \pi \quad \Rightarrow \quad A \sigma \sqrt{2\pi} \approx \pi
\end{equation}

\subsubsection{DRAG Pulses}

DRAG (Derivative Removal by Adiabatic Gate) pulses suppress leakage to non-computational states in weakly anharmonic systems (e.g., transmon qubits). The DRAG correction adds a quadrature component proportional to the derivative:
\begin{align}
\Omega_I(t) &= A \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right) \\
\Omega_Q(t) &= -\beta \frac{d\Omega_I}{dt} = \beta A \frac{t - t_c}{\sigma^2} \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right)
\end{align}

The control Hamiltonian becomes:
\begin{equation}
\hat{H}_c(t) = \frac{\Omega_I(t)}{2} \sigma_x + \frac{\Omega_Q(t)}{2} \sigma_y
\end{equation}

The DRAG coefficient $\beta$ is chosen to cancel first-order leakage: $\beta \approx -\alpha / (2\Omega_{\max})$ where $\alpha$ is the anharmonicity.

\subsection{Detuning Effects}

For off-resonance driving ($\Delta \neq 0$), the effective Rabi frequency is modified:
\begin{equation}
\Omega_{\text{eff}} = \sqrt{\Omega^2 + \Delta^2}
\end{equation}

The maximum population transfer to $\ket{1}$ is reduced:
\begin{equation}
P_{1,\max} = \frac{\Omega^2}{\Omega^2 + \Delta^2}
\end{equation}

Large detuning ($|\Delta| \gg \Omega$) strongly suppresses population transfer, providing spectral selectivity in multi-qubit systems.

\subsection{Implementation}

\subsubsection{ControlHamiltonian Class}

Implemented in \texttt{src/hamiltonian/control.py}:

\begin{lstlisting}[caption={ControlHamiltonian class structure}]
class ControlHamiltonian:
    def __init__(self, pulse_func, drive_axis='x',
                 phase=0.0, detuning=0.0):
        # Store pulse envelope function Omega(t)
        # Configure drive axis (x, y, or xy for DRAG)
        # Set phase and detuning parameters

    def hamiltonian(self, t):
        # Return H_c(t) at time t
        # Apply RWA with phase rotation

    def evolve_state(self, psi0, times, H_drift=None):
        # Evolve state under H_total = H_drift + H_c(t)
        # Use QuTiP's sesolve with time-dependent H

    def gate_fidelity(self, psi0, psi_target, times):
        # Compute F = |<psi_target|psi_final>|^2
\end{lstlisting}

\subsubsection{Pulse Shape Generators}

Module \texttt{src/pulses/shapes.py} provides:
\begin{itemize}
    \item \texttt{gaussian\_pulse(times, amplitude, t\_center, sigma)}
    \item \texttt{square\_pulse(times, amplitude, t\_start, t\_end)}
    \item \texttt{drag\_pulse(times, amplitude, t\_center, sigma, beta)}
    \item \texttt{cosine\_pulse(times, amplitude, t\_start, t\_end)}
    \item \texttt{blackman\_pulse(times, amplitude, t\_start, t\_end)}
    \item Utility: \texttt{pulse\_area(times, pulse)} for integration
    \item Utility: \texttt{scale\_pulse\_to\_target\_angle(pulse, times, angle)}
\end{itemize}

\subsection{Validation and Testing}

\subsubsection{Test Coverage}

\textbf{Pulse Shapes} (\texttt{tests/unit/test\_pulses.py}): 40 tests
\begin{itemize}
    \item Gaussian: amplitude, symmetry, width (FWHM), integration accuracy
    \item Square: flat-top, rise times, boundary conditions
    \item DRAG: I/Q components, derivative correctness, antisymmetry
    \item Blackman/Cosine: smooth edges, spectral properties
    \item Utilities: pulse area calculation, scaling to target angle
\end{itemize}

\textbf{Control Hamiltonian} (\texttt{tests/unit/test\_control.py}): 34 tests
\begin{itemize}
    \item Construction: drive axes (x, y, xy), phase, detuning
    \item Rabi oscillations: $\pi$-pulse, $\pi/2$-pulse, periodicity
    \item Detuning effects: on/off-resonance, population suppression
    \item Gate fidelity: duration sensitivity, drift Hamiltonian interaction
    \item Phase control: arbitrary rotation axes in x-y plane
\end{itemize}

\textbf{Results:} 74/74 tests passing (combined pulse + control), 100\% code coverage.

\subsubsection{Rabi Oscillation Validation}

Validation confirms theoretical predictions:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Gate} & \textbf{Target Fidelity} & \textbf{Achieved Fidelity} \\
\midrule
$\pi$-pulse (X-gate) & $\ket{1}$ & $F > 0.9999$ \\
$\pi/2$-pulse & $({\ket{0} - i\ket{1}})/\sqrt{2}$ & $F > 0.999$ \\
Constant driving (3 periods) & Periodic return to $\ket{0}$ & $F > 0.99$ \\
\bottomrule
\end{tabular}
\caption{Gate fidelity validation for constant Rabi driving at $\Omega_0 = 2\pi \times 10$ MHz.}
\end{table}

\subsection{Demonstration Notebook}

\texttt{notebooks/02\_rabi\_oscillations.ipynb} provides interactive demonstrations:
\begin{itemize}
    \item Rabi oscillations with Bloch sphere trajectories
    \item $\pi$ and $\pi/2$ pulse gate synthesis
    \item Pulse shape comparison (Gaussian, square, cosine): time-domain and frequency-domain analysis
    \item DRAG pulse I/Q components and antisymmetry verification
    \item Detuning scan: population transfer vs.\ $\Delta$
    \item Gate fidelity sensitivity to pulse duration
\end{itemize}

\subsection{Summary of Phase 1.3 Deliverables}

\begin{itemize}
    \item Mathematical derivation: rotating frame, RWA, Rabi oscillations
    \item ControlHamiltonian class: time-dependent driving, phase control, detuning
    \item Pulse shape library: Gaussian, square, DRAG, cosine, Blackman
    \item Validation: 74 unit tests (40 pulses + 34 control), 100\% pass rate
    \item Demonstration: Interactive Jupyter notebook with visualizations
    \item Gate synthesis: $\pi$ and $\pi/2$ pulses with $F > 0.999$
\end{itemize}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/hamiltonian/control.py} — ControlHamiltonian class
    \item \texttt{src/pulses/shapes.py} — Pulse shape generators
    \item \texttt{tests/unit/test\_control.py} — Control Hamiltonian tests
    \item \texttt{tests/unit/test\_pulses.py} — Pulse shape tests
    \item \texttt{notebooks/02\_rabi\_oscillations.ipynb} — Interactive demonstration
\end{itemize}

%==============================================================================
\section{Phase 2: Optimal Control Theory}
\label{sec:phase2}
%==============================================================================

\subsection{Overview}

Phase 2 implements gradient-based optimal control algorithms for designing high-fidelity quantum gates. The goal is to find control pulse shapes $\Omega(t)$ that maximize the fidelity between the implemented operation and a target unitary $U_{\text{target}}$, while respecting physical constraints (amplitude limits, bandwidth, total time).

\subsection{Optimal Control Problem Formulation}

\subsubsection{Fidelity Metrics}

For quantum gate optimization, we consider two primary fidelity measures:

\begin{definition}[State Fidelity]
For an initial state $\ket{\psi_0}$ evolving to $\ket{\psi(T)}$ under control Hamiltonian, the state fidelity is:
\begin{equation}
F_{\text{state}} = |\braket{\psi_{\text{target}}}{\psi(T)}|^2
\end{equation}
\end{definition}

\begin{definition}[Unitary Fidelity]
For gate operations, the average gate fidelity over all input states is:
\begin{equation}
F_{\text{gate}} = \frac{1}{d^2}|\Tr(U_{\text{target}}^\dagger U(T))|^2
\end{equation}
where $d$ is the Hilbert space dimension (for qubits, $d=2$).
\end{definition}

\subsubsection{Constrained Optimization}

The optimal control problem is formulated as:
\begin{equation}
\begin{aligned}
\max_{\{\Omega_k\}} \quad & F(\{\Omega_k\}) \\
\text{subject to} \quad & |\Omega_k| \leq \Omega_{\text{max}} \quad \forall k \\
& \sum_k \Delta t = T
\end{aligned}
\end{equation}
where $\{\Omega_k\}$ are piecewise-constant control amplitudes over time slices.

\subsection{GRAPE Algorithm}

\subsubsection{Gradient Computation}

GRAPE (GRadient Ascent Pulse Engineering) uses analytical gradients of fidelity with respect to control parameters. For state transfer with Hamiltonian $H(t) = H_0 + \sum_j u_j(t) H_j$, the gradient is:
\begin{equation}
\frac{\partial F}{\partial u_j(t_k)} = 2\Re\left[\bra{\chi(t_k)} H_j \ket{\psi(t_k)}\right]
\end{equation}
where $\ket{\chi(t)}$ is the backward-propagated state from $\ket{\psi_{\text{target}}}$.

\subsubsection{Update Rule}

The GRAPE algorithm iterates:
\begin{enumerate}
    \item Forward propagate: $\ket{\psi(t_{k+1})} = e^{-iH(t_k)\Delta t}\ket{\psi(t_k)}$
    \item Backward propagate: $\ket{\chi(t_k)} = e^{-iH(t_k)\Delta t}\ket{\chi(t_{k+1})}$
    \item Compute gradients: $\nabla_{u_j(t_k)} F$
    \item Update controls: $u_j(t_k) \leftarrow u_j(t_k) + \epsilon \nabla_{u_j(t_k)} F$
    \item Project to constraints: $u_j(t_k) \leftarrow \min(\max(u_j(t_k), -\Omega_{\text{max}}), \Omega_{\text{max}})$
\end{enumerate}

\subsection{Krotov's Method}

Krotov's method provides monotonic convergence guarantees through a penalty-based update:
\begin{equation}
u_j^{(n+1)}(t) = u_j^{(n)}(t) + \frac{1}{\lambda} \Im\left[\bra{\chi^{(n)}(t)} H_j \ket{\psi^{(n)}(t)}\right]
\end{equation}
where $\lambda > 0$ is a step-size parameter controlling convergence rate.

\textbf{Advantages over GRAPE:}
\begin{itemize}
    \item Monotonic convergence: $F^{(n+1)} \geq F^{(n)}$
    \item No line search required
    \item Smooth pulse updates
\end{itemize}

\subsection{Robustness Analysis}

\subsubsection{Parameter Sensitivity}

For practical implementation, control pulses must be robust against:
\begin{itemize}
    \item \textbf{Detuning errors}: $\omega_{\text{drive}} \neq \omega_0$
    \item \textbf{Amplitude errors}: $\Omega_{\text{actual}} = (1+\epsilon)\Omega_{\text{nominal}}$
    \item \textbf{Timing jitter}: $t \rightarrow t + \delta t$
\end{itemize}

The sensitivity is quantified by:
\begin{equation}
S_\theta = \left|\frac{\partial F}{\partial \theta}\right|
\end{equation}
for parameter $\theta$ (detuning, amplitude, etc.).

\subsubsection{Noise Robustness}

For Gaussian amplitude noise $\delta\Omega(t) \sim \mathcal{N}(0, \sigma^2)$, the average fidelity is:
\begin{equation}
\langle F \rangle = \int F(\Omega + \delta\Omega) P(\delta\Omega) d\delta\Omega
\end{equation}

\subsection{Implementation}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/optimization/grape.py} — GRAPE optimizer class (315 lines)
    \item \texttt{src/optimization/krotov.py} — Krotov optimizer class (298 lines)
    \item \texttt{src/optimization/robustness.py} — Robustness testing framework (932 lines)
    \item \texttt{tests/unit/test\_grape.py} — GRAPE algorithm tests (37 tests)
    \item \texttt{tests/unit/test\_krotov.py} — Krotov algorithm tests (36 tests)
    \item \texttt{tests/unit/test\_robustness.py} — Robustness tests (15 tests)
\end{itemize}

\textbf{Validation Results:}
\begin{itemize}
    \item X-gate fidelity: $F > 0.9999$ (500 iterations)
    \item Hadamard gate: $F > 0.999$ (300 iterations)
    \item Robustness: $\langle F \rangle > 0.95$ for 10\% amplitude noise
\end{itemize}

%==============================================================================
\section{Phase 3: Advanced Pulse Shaping and Benchmarking}
\label{sec:phase3}
%==============================================================================

\subsection{Overview}

Phase 3 extends the control framework with advanced pulse shaping techniques, gate compilation, and comprehensive benchmarking protocols. These methods address leakage suppression, composite pulse robustness, adiabatic passage, and hardware-independent gate characterization.

\subsection{Task 1: Advanced Pulse Shaping}

\subsubsection{DRAG Pulses}

Derivative Removal by Adiabatic Gate (DRAG) suppresses leakage to non-computational states in weakly anharmonic systems. For a qubit with leakage level $\ket{2}$, the DRAG Hamiltonian is:
\begin{equation}
H_{\text{DRAG}}(t) = \Omega(t)\cos(\omega t)\sigma_x - \beta\dot{\Omega}(t)\sin(\omega t)\sigma_y
\end{equation}
where $\beta = 1/\delta$ with $\delta$ the anharmonicity.

\textbf{Theoretical Basis:} The $\sigma_y$ term cancels the leading-order leakage error:
\begin{equation}
\epsilon_{\text{leakage}} \propto \frac{\Omega^2}{\delta^2} \rightarrow 0 \text{ with DRAG}
\end{equation}

\subsubsection{Composite Pulses}

Composite pulses achieve robustness through sequences of imperfect operations that cancel systematic errors. For example, the BB1 (Broadband 1) sequence:
\begin{equation}
U_{\text{BB1}} = X_{\phi_3} X_{\phi_2} X_{\phi_1} X_{\phi_0}
\end{equation}
with phases $\phi = [\pi, 3\pi, 3\pi, \pi]$ compensates for pulse amplitude errors to second order.

\textbf{Key Composite Sequences:}
\begin{itemize}
    \item \textbf{BB1}: Broadband, compensates amplitude and detuning errors
    \item \textbf{CORPSE}: Compensation for Off-Resonance with Pulse Sequence
    \item \textbf{SCROFULOUS}: Short Composite Rotation For Undoing Length Over- and Under-Shoot
\end{itemize}

\subsubsection{Adiabatic Techniques}

\textbf{Adiabatic Theorem:} A system in eigenstate $\ket{n(0)}$ remains in the instantaneous eigenstate $\ket{n(t)}$ if the Hamiltonian changes sufficiently slowly:
\begin{equation}
\left|\frac{\bra{m(t)}\dot{H}(t)\ket{n(t)}}{(E_n - E_m)^2}\right| \ll 1
\end{equation}

\textbf{STIRAP (Stimulated Raman Adiabatic Passage):} Robust population transfer using two time-delayed pulses in counterintuitive order:
\begin{equation}
H_{\text{STIRAP}}(t) = \Omega_p(t)\ket{1}\bra{0} + \Omega_s(t)\ket{2}\bra{1} + \text{h.c.}
\end{equation}
with Stokes pulse $\Omega_s$ before pump $\Omega_p$.

\subsection{Task 2: Gate Library and Compilation}

\subsubsection{Universal Single-Qubit Gates}

Any single-qubit unitary can be decomposed as:
\begin{equation}
U = e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)
\end{equation}
where $R_j(\theta) = e^{-i\theta\sigma_j/2}$ are rotation operators.

\textbf{Implemented Gates:}
\begin{itemize}
    \item Identity: $I$
    \item Pauli gates: $X, Y, Z$
    \item Hadamard: $H = \frac{1}{\sqrt{2}}(X + Z)$
    \item Phase gates: $S = \sqrt{Z}, T = \sqrt{S}$
    \item Arbitrary rotations: $R_{\hat{n}}(\theta)$
\end{itemize}

\subsubsection{Euler Decomposition}

The ZYZ decomposition extracts rotation angles:
\begin{equation}
U = \begin{pmatrix} u_{00} & u_{01} \\ u_{10} & u_{11} \end{pmatrix} = e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)
\end{equation}
with:
\begin{align}
\gamma &= 2\arccos(|u_{00}|) \\
\beta &= \arg(u_{00}) - \arg(u_{01}) \\
\delta &= \arg(u_{00}) + \arg(u_{01})
\end{align}

\subsubsection{Gate Compilation}

\textbf{Compilation Strategies:}
\begin{enumerate}
    \item \textbf{Sequential}: Optimize each gate independently, concatenate
    \item \textbf{Joint}: Optimize entire gate sequence simultaneously
    \item \textbf{Hybrid}: Sequential with joint refinement
\end{enumerate}

\subsection{Task 3: Enhanced Robustness and Benchmarking}

\subsubsection{Filter Functions}

Filter functions characterize pulse sensitivity to noise at different frequencies:
\begin{equation}
F(\omega) = \left|\int_0^T y(t)e^{i\omega t}dt\right|^2
\end{equation}
where $y(t)$ is the control modulation.

\textbf{Noise Infidelity:}
\begin{equation}
\chi = \frac{1}{2\pi}\int F(\omega)S(\omega)d\omega
\end{equation}
for noise power spectral density $S(\omega)$.

\textbf{Common Noise Models:}
\begin{itemize}
    \item White noise: $S(\omega) = S_0$
    \item $1/f$ noise: $S(\omega) = A/|\omega|^\alpha$
    \item Lorentzian: $S(\omega) = A/(1 + (\omega/\omega_c)^2)$
\end{itemize}

\subsubsection{Randomized Benchmarking}

Randomized Benchmarking (RB) extracts average gate fidelity via decay of survival probability:
\begin{equation}
F_{\text{seq}}(m) = A p^m + B
\end{equation}
for sequence length $m$, with depolarizing parameter $p$ related to average gate fidelity:
\begin{equation}
F_{\text{avg}} = 1 - \frac{(1-p)(d-1)}{d}
\end{equation}

\textbf{Clifford Group:} The 24-element single-qubit Clifford group is generated by Hadamard $H$ and phase gate $S = \text{diag}(1, i)$.

\textbf{Interleaved RB:} Characterizes specific gate $G$ by interleaving it between random Cliffords:
\begin{equation}
F_G = 1 - \frac{(1 - p_{\text{int}}/p_{\text{std}})(d-1)}{d}
\end{equation}

\subsubsection{Fisher Information}

Quantum Fisher information quantifies parameter estimation precision:
\begin{equation}
F(\theta) = \Tr[\rho L^2]
\end{equation}
where $L$ is the symmetric logarithmic derivative satisfying:
\begin{equation}
\frac{\partial\rho}{\partial\theta} = \frac{1}{2}(L\rho + \rho L)
\end{equation}

\textbf{Cramér-Rao Bound:} The variance of any unbiased estimator satisfies:
\begin{equation}
\text{Var}(\hat{\theta}) \geq \frac{1}{NF(\theta)}
\end{equation}
for $N$ measurements.

\subsection{Implementation Summary}

\textbf{Phase 3 Modules:}
\begin{itemize}
    \item \texttt{src/pulses/drag.py} — DRAG pulse implementation (347 lines)
    \item \texttt{src/pulses/composite.py} — Composite pulse sequences (419 lines)
    \item \texttt{src/pulses/adiabatic.py} — Adiabatic passage techniques (508 lines)
    \item \texttt{src/optimization/gates.py} — Universal gate library (502 lines)
    \item \texttt{src/optimization/compilation.py} — Gate compilation (481 lines)
    \item \texttt{src/optimization/filter\_functions.py} — Filter function analysis (673 lines)
    \item \texttt{src/optimization/benchmarking.py} — Randomized benchmarking (679 lines)
\end{itemize}

\textbf{Test Coverage:}
\begin{itemize}
    \item DRAG pulses: 49 tests
    \item Composite pulses: 40 tests
    \item Adiabatic techniques: 44 tests
    \item Gate optimization: 50 tests
    \item Gate compilation: 45 tests
    \item Filter functions: 42 tests
    \item Randomized benchmarking: 41 tests
    \item \textbf{Total Phase 3 tests: 311} (all passing)
\end{itemize}

\textbf{Documentation:}
\begin{itemize}
    \item \texttt{docs/TASK\_1\_SUMMARY.md} — Advanced pulse shaping
    \item \texttt{docs/TASK\_2\_SUMMARY.md} — Gate library and compilation
    \item \texttt{docs/TASK\_3\_SUMMARY.md} — Robustness and benchmarking
    \item \texttt{examples/task3\_demo.py} — Demonstration script
\end{itemize}

%==============================================================================
\section{Future Work}
%==============================================================================

\subsection{Planned Extensions}

Future development phases will address:

\begin{itemize}
    \item \textbf{Two-Qubit Gates:} CNOT, CZ, iSWAP optimization with entangling Hamiltonians
    \item \textbf{Open System Dynamics:} Lindblad master equation with $T_1$, $T_2$ decoherence
    \item \textbf{Visualization Tools:} Interactive dashboards, Bloch sphere animations
    \item \textbf{GPU Acceleration:} JAX implementation for gradient computations
    \item \textbf{Hardware Integration:} Export to experimental pulse compiler formats
    \item \textbf{Quantum Error Correction:} Logical gate optimization for stabilizer codes
\end{itemize}

Each extension will follow the established pattern: theoretical derivation, implementation with comprehensive testing, and validation against analytical or published results.

%==============================================================================
\section{Conclusion}
%==============================================================================

This document establishes the comprehensive theoretical and computational foundations for the QubitPulseOpt quantum control simulation framework. Phase 1 develops the computational infrastructure, drift Hamiltonian formalism, and control Hamiltonians with analytical validation. Phase 2 implements optimal control algorithms (GRAPE, Krotov) with extensive robustness testing. Phase 3 provides advanced pulse shaping techniques (DRAG, composite pulses, adiabatic passage), universal gate compilation, and comprehensive benchmarking protocols (filter functions, randomized benchmarking, Fisher information).

The framework comprises over 4,500 lines of production code with 450+ unit tests (all passing), extensive documentation, and demonstration scripts. All implementations are validated against analytical results or published literature, ensuring scientific rigor and reproducibility.

This document serves as the authoritative reference for all physics, mathematics, and implementation decisions, and will continue to be updated as new capabilities are added.

%==============================================================================
\section*{References}
\addcontentsline{toc}{section}{References}
%==============================================================================

\begin{enumerate}[label={[\arabic*]}]
    \item M.~A. Nielsen and I.~L. Chuang, \emph{Quantum Computation and Quantum Information}, Cambridge University Press (2010).
    \item J.~Johansson, P.~Nation, and F.~Nori, ``QuTiP: An open-source Python framework for the dynamics of open quantum systems,'' \emph{Computer Physics Communications} \textbf{183}, 1760 (2012).
    \item N.~Khaneja, T.~Reiss, C.~Kehlet, T.~Schulte-Herbr\"uggen, and S.~J. Glaser, ``Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms,'' \emph{Journal of Magnetic Resonance} \textbf{172}, 296 (2005).
    \item D.~M. Reich, M.~Ndong, and C.~P. Koch, ``Monotonically convergent optimization in quantum control using Krotov's method,'' \emph{The Journal of Chemical Physics} \textbf{136}, 104103 (2012).
    \item F.~Motzoi, J.~M. Gambetta, P.~Rebentrost, and F.~K. Wilhelm, ``Simple pulses for elimination of leakage in weakly nonlinear qubits,'' \emph{Physical Review Letters} \textbf{103}, 110501 (2009).
    \item S.~Machnes, U.~Sander, S.~J. Glaser, P.~de Fouquières, A.~Gruslys, S.~Schirmer, and T.~Schulte-Herbr\"uggen, ``Comparing, optimizing, and benchmarking quantum-control algorithms in a unifying programming framework,'' \emph{Physical Review A} \textbf{84}, 022305 (2011).
    \item T.~J. Green, J.~Sastrawan, H.~Uys, and M.~J. Biercuk, ``Arbitrary quantum control of qubits in the presence of universal noise,'' \emph{New Journal of Physics} \textbf{15}, 095004 (2013).
    \item E.~Knill et al., ``Randomized benchmarking of quantum gates,'' \emph{Physical Review A} \textbf{77}, 012307 (2008).
    \item E.~Magesan, J.~M. Gambetta, and J.~Emerson, ``Scalable and robust randomized benchmarking of quantum processes,'' \emph{Physical Review Letters} \textbf{109}, 080505 (2012).
    \item K.~Bergmann, H.~Theuer, and B.~W. Shore, ``Coherent population transfer among quantum states of atoms and molecules,'' \emph{Reviews of Modern Physics} \textbf{70}, 1003 (1998).
    \item H.~K. Cummins, G.~Llewellyn, and J.~A. Jones, ``Tackling systematic errors in quantum logic gates with composite rotations,'' \emph{Physical Review A} \textbf{67}, 042308 (2003).
    \item S.~L. Braunstein and C.~M. Caves, ``Statistical distance and the geometry of quantum states,'' \emph{Physical Review Letters} \textbf{72}, 3439 (1994).
\end{enumerate}

%==============================================================================
\appendix
\section{Appendix: QuTiP API Reference}
\label{app:qutip}
%==============================================================================

For reference, we summarize key QuTiP 5.x API functions used in this project:

\begin{itemize}
    \item \texttt{qt.basis(N, k)} — Returns $\ket{k}$ in $N$-dimensional Hilbert space (e.g., \texttt{qt.basis(2, 0)} = $\ket{0}$).
    \item \texttt{qt.sigmax()}, \texttt{qt.sigmay()}, \texttt{qt.sigmaz()} — Pauli matrices as \texttt{Qobj}.
    \item \texttt{qt.qeye(N)} — Identity operator on $\CC^N$.
    \item \texttt{qt.sesolve(H, psi0, tlist, e\_ops=[])} — Schrödinger equation solver. Returns \texttt{Result} with \texttt{.states} (list of states) and \texttt{.expect} (expectation values if \texttt{e\_ops} provided).
    \item \texttt{qt.expect(op, state)} — Compute $\bra{\psi} \hat{O} \ket{\psi}$.
    \item \texttt{qt.fidelity(psi1, psi2)} — State fidelity $|\braket{\psi_1}{\psi_2}|^2$.
    \item \texttt{qt.Bloch()} — Bloch sphere plotting. Methods: \texttt{.add\_states(states)}, \texttt{.add\_points([x, y, z], meth='l')}, \texttt{.show()}.
\end{itemize}

All QuTiP functions preserve quantum object types (\texttt{Qobj}) and automatically validate dimensions, Hermiticity, and normalization.

\end{document}
