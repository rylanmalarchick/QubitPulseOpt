\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{enumitem}

% Page geometry
\geometry{margin=1in}

% Header/Footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Quantum Control Theory: QubitPulseOpt}
\lhead{Phases 1--3}
\rfoot{Page \thepage}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=green,
}

% Code listing style
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
}
\lstset{style=pythonstyle}

% Theorem environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]

% Custom commands
% Note: \ket, \bra, \braket are provided by physics package
\renewcommand{\Tr}{\operatorname{Tr}}
\newcommand{\paulix}{\sigma_x}
\newcommand{\pauliy}{\sigma_y}
\newcommand{\pauliz}{\sigma_z}
\newcommand{\identity}{\mathbb{I}}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\hamiltonian}{\mathcal{H}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}

% Title
\title{\textbf{Quantum Control Theory and Implementation}\\
\Large QubitPulseOpt: A Simulation Framework for\\
Optimal Quantum Control of Two-Level Systems}
\author{Rylan Malarchick\\
\small Quantum Controls Simulation Project}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document provides a comprehensive theoretical foundation and implementation guide for the QubitPulseOpt quantum control simulation framework. We develop the mathematical formalism for controlling two-level quantum systems (qubits) using time-dependent electromagnetic pulses, building from first principles to advanced optimal control techniques. The treatment is organized by project phases, with each phase introducing new theoretical concepts alongside their computational implementations. Phase 1 establishes the computational environment, drift Hamiltonian formalism, and control Hamiltonians. Phase 2 implements optimal control algorithms (GRAPE, Krotov) with comprehensive robustness testing. Phase 3 develops advanced pulse shaping techniques, gate compilation, and benchmarking protocols. This document serves as the authoritative reference for all physics, mathematics, and implementation decisions in the QubitPulseOpt framework.
\end{abstract}

\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

\subsection{Motivation and Scope}

Quantum control theory addresses the fundamental challenge of manipulating quantum systems to achieve desired target states or operations with high fidelity. For two-level systems (qubits)---the basic unit of quantum information---this control is typically achieved through resonant or near-resonant electromagnetic pulses. The QubitPulseOpt framework provides a rigorous simulation environment for:

\begin{enumerate}[label=(\roman*)]
    \item Modeling qubit dynamics under drift and control Hamiltonians
    \item Designing and optimizing control pulse shapes
    \item Analyzing decoherence and relaxation effects
    \item Implementing gradient-based optimal control algorithms (GRAPE, Krotov)
    \item Validating control fidelity via numerical and analytical methods
\end{enumerate}

This document is structured to mirror the phased development of the QubitPulseOpt codebase, with each section corresponding to a specific development phase. All theoretical results are accompanied by explicit mappings to implementation files, test suites, and demonstration notebooks.

\subsection{Mathematical Conventions}

Throughout this document, we adopt the following conventions:

\begin{itemize}
    \item We work in units where $\hbar = 1$ unless explicitly stated otherwise.
    \item Quantum states are denoted by ket vectors $\ket{\psi} \in \hilbert$, where $\hilbert$ is the Hilbert space (typically $\hilbert = \CC^2$ for a qubit).
    \item Observables and operators are represented by calligraphic or bold letters (e.g., $\hat{H}$, $\hat{\rho}$).
    \item Time-dependent quantities are explicitly written as functions of $t$.
    \item The Pauli matrices are defined as:
    \begin{equation}
    \paulix = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad
    \pauliy = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}, \quad
    \pauliz = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
    \end{equation}
    \item The identity operator on $\CC^2$ is denoted $\identity$.
\end{itemize}

%==============================================================================
\section{Phase 1.1: Computational Infrastructure and Reproducibility}
\label{sec:phase1.1}
%==============================================================================

\subsection{Overview}

Before developing quantum control algorithms, we must establish a robust, reproducible computational environment. Phase 1.1 addresses the foundational infrastructure requirements: version control, dependency management, environment isolation, and validation protocols. This phase ensures that all subsequent theoretical developments can be implemented, tested, and reproduced by independent researchers or on different computational platforms.

\subsection{Environment Design Philosophy}

\subsubsection{Reproducibility Requirements}

Scientific computing demands bitwise-reproducible results across different machines and time periods. For the QubitPulseOpt framework, reproducibility is achieved through:

\begin{enumerate}[label=\arabic*.]
    \item \textbf{Environment Isolation:} All Python dependencies are installed in an isolated virtual environment, preventing version conflicts with system packages or other projects.
    \item \textbf{Explicit Dependency Specification:} Exact versions of all packages are documented in \texttt{environment.yml} (for Conda) and can be captured via \texttt{pip freeze} for venv users.
    \item \textbf{Version Control:} All source code, documentation, and configuration files are tracked via Git and hosted on GitHub (\url{https://github.com/rylanmalarchick/QubitPulseOpt}).
    \item \textbf{Automated Validation:} Setup validation scripts ensure that the environment is correctly configured before scientific work begins.
\end{enumerate}

\subsubsection{Virtual Environment vs. Conda}

Two primary approaches exist for Python environment management:

\begin{description}
    \item[\texttt{venv} (Python's built-in virtual environment):] Lightweight, no external dependencies, straightforward activation. Used as the primary environment for QubitPulseOpt.
    \begin{itemize}
        \item \textbf{Pros:} Ships with Python 3.3+, minimal overhead, integrates seamlessly with pip.
        \item \textbf{Cons:} Does not manage non-Python dependencies (e.g., BLAS, LAPACK for NumPy/SciPy optimization).
    \end{itemize}

    \item[\texttt{conda} (Anaconda/Miniconda):] Cross-language package manager, handles compiled dependencies.
    \begin{itemize}
        \item \textbf{Pros:} Manages both Python and system-level libraries (e.g., MKL-optimized NumPy), good for complex scientific stacks.
        \item \textbf{Cons:} Larger installation footprint, potential conflicts between conda and pip packages.
    \end{itemize}
\end{description}

\textbf{Decision:} QubitPulseOpt uses \texttt{venv} as the default environment, with \texttt{environment.yml} provided as an alternative for Conda users. This decision balances simplicity (venv is universally available) with flexibility (Conda users can replicate the environment exactly).

\subsection{Core Dependencies}

The QubitPulseOpt framework relies on the following Python packages:

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Package} & \textbf{Version} & \textbf{Purpose} \\
\midrule
QuTiP & 5.2.1 & Quantum Toolbox in Python; provides quantum state/operator representations, Hamiltonian evolution solvers (Schrödinger, Lindblad), and Bloch sphere visualization. \\
NumPy & 2.3.4 & Numerical array operations, linear algebra, Fourier transforms. \\
SciPy & 1.16.2 & Advanced scientific computing: ODE solvers, optimization routines, special functions. \\
Matplotlib & 3.10.7 & Plotting and visualization of quantum dynamics, control pulses, and convergence metrics. \\
Jupyter & (latest) & Interactive notebook environment for demonstrations and exploratory analysis. \\
pytest & (latest) & Unit testing framework; ensures correctness of all modules. \\
pytest-cov & (latest) & Code coverage analysis for test suites. \\
\bottomrule
\end{tabular}
\caption{Core dependencies for QubitPulseOpt with version information and usage descriptions.}
\label{tab:dependencies}
\end{table}

\subsubsection{QuTiP Installation Notes}

QuTiP (Quantum Toolbox in Python) is the central dependency. Version 5.x introduces significant API changes compared to 4.x:

\begin{itemize}
    \item \textbf{Solver Interface:} The \texttt{sesolve} function (Schrödinger equation solver) now returns a \texttt{Result} object with state trajectories accessed via \texttt{result.states}.
    \item \textbf{Bloch Sphere Plotting:} The \texttt{Bloch.add\_points} method requires the \texttt{meth} parameter to be one of \texttt{\{'s', 'l', 'm'\}} (single point, line, multi-point). Colors are set via \texttt{point\_color}, \texttt{point\_marker}, etc., rather than passed directly to \texttt{add\_points}.
    \item \textbf{Quantum Objects:} States and operators are represented as \texttt{Qobj} instances. Hermiticity, normalization, and dimensionality are automatically validated.
\end{itemize}

These API details are critical for Phase 1.2 implementations (drift Hamiltonian evolution) and later phases (control pulse simulations).

\subsection{Repository Structure}

The QubitPulseOpt repository follows a modular, hierarchical structure:

\begin{verbatim}
quantumControls/
  src/
    __init__.py
    hamiltonian/
      __init__.py
      drift.py          # Drift Hamiltonian (Phase 1.2)
      evolution.py      # Time evolution engine (Phase 1.2)
      control.py        # Control Hamiltonian (Phase 1.3, future)
    pulses/             # Pulse shapes (future)
    optimization/       # GRAPE, Krotov (future)
    visualization/      # Plotting utilities (future)
  tests/
    unit/
      test_drift.py     # Unit tests for drift.py
      ...
    integration/        # End-to-end tests (future)
  notebooks/
    01_drift_dynamics.ipynb    # Phase 1.2 demonstration
    ...
  scripts/
    validate_setup.sh     # Environment validation
    activate_env.sh       # Activate venv helper
    verify_drift_evolution.py  # Standalone drift test
  docs/
    science/
      quantum_control_theory.tex  # This document
    SETUP_COMPLETE.md
    REVIEW_SUMMARY.md
  environment.yml       # Conda environment spec
  README.md
  .gitignore
\end{verbatim}

This structure separates concerns: \texttt{src/} contains all production code, \texttt{tests/} validates correctness, \texttt{notebooks/} provides interactive demonstrations, and \texttt{docs/} maintains theoretical documentation.

\subsection{Validation Protocol}

To ensure the environment is correctly configured, we implement a multi-stage validation protocol:

\begin{enumerate}[label=\textbf{Stage \arabic*:}]
    \item \textbf{Python Version Check:} Verify Python $\geq$ 3.8 (required for QuTiP 5.x and modern NumPy).
    \item \textbf{Package Import Test:} Attempt to import all core packages (QuTiP, NumPy, SciPy, Matplotlib) and verify versions.
    \item \textbf{QuTiP Functionality Test:} Create a simple quantum state $\ket{0}$, apply a Pauli-X gate, and verify $\paulix \ket{0} = \ket{1}$ to within numerical precision.
    \item \textbf{Numerical Precision Test:} Confirm that NumPy/SciPy linear algebra operations achieve machine precision ($\sim 10^{-16}$ for double-precision floats).
\end{enumerate}

The validation script \texttt{scripts/validate\_setup.sh} orchestrates these checks. A successful run outputs:

\begin{verbatim}
[PASS] Python version: 3.12.3
[PASS] QuTiP 5.2.1 imported successfully
[PASS] NumPy 2.3.4 imported successfully
[PASS] SciPy 1.16.2 imported successfully
[PASS] Matplotlib 3.10.7 imported successfully
[PASS] Basic QuTiP test: |0> -> |1> via Pauli-X
[PASS] Numerical precision: ||I - I|| = 0.0
All validation checks passed.
\end{verbatim}

\subsection{Git Workflow and Version Control}

The project uses Git for version control with the following practices:

\begin{itemize}
    \item \textbf{Branch Strategy:} Development occurs on the \texttt{main} branch initially; feature branches will be used for major new components (e.g., \texttt{feature/grape-optimizer}).
    \item \textbf{Commit Messages:} Follow conventional commit format: \texttt{type(scope): description}, e.g., \texttt{feat(drift): implement analytical propagator for H0}.
    \item \textbf{Remote Repository:} Hosted at \url{https://github.com/rylanmalarchick/QubitPulseOpt}. All development is pushed regularly to ensure cloud backup and collaboration readiness.
\end{itemize}

\subsection{Summary of Phase 1.1 Deliverables}

\begin{itemize}
    \item Git repository initialized and pushed to GitHub.
    \item Virtual environment created with all core dependencies installed.
    \item Repository structure established (src/, tests/, notebooks/, docs/).
    \item Validation scripts implemented and passing.
    \item Documentation of environment setup in README.md and SETUP\_COMPLETE.md.
\end{itemize}

\textbf{Code Mapping:} Configuration files (\texttt{environment.yml}, \texttt{.gitignore}), validation scripts (\texttt{scripts/validate\_setup.sh}, \texttt{scripts/test\_env\_simple.py}), and documentation (\texttt{docs/SETUP\_COMPLETE.md}).

%==============================================================================
\section{Phase 1.2: Drift Hamiltonian and Free Evolution}
\label{sec:phase1.2}
%==============================================================================

\subsection{Overview}

Phase 1.2 establishes the theoretical and computational framework for the \emph{drift Hamiltonian} $\hat{H}_0$, which governs the natural evolution of a qubit in the absence of external control fields. Understanding drift dynamics is prerequisite to designing control pulses, as optimal control effectively steers the system away from its natural trajectory toward a desired target state.

We develop the drift Hamiltonian for a qubit in a static magnetic field, derive analytical solutions for time evolution, implement numerical solvers for validation, and demonstrate the equivalence of analytical and numerical methods to machine precision.

\subsection{Two-Level Systems and the Qubit Hilbert Space}

\begin{definition}[Qubit]
A \emph{qubit} is a two-level quantum system whose state space is the two-dimensional complex Hilbert space $\hilbert = \CC^2$. The computational basis states are:
\begin{equation}
\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, \quad
\ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}
\end{equation}
Any pure state $\ket{\psi} \in \hilbert$ can be written as:
\begin{equation}
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}, \quad \alpha, \beta \in \CC, \quad |\alpha|^2 + |\beta|^2 = 1
\end{equation}
\end{definition}

The Pauli matrices $\{\paulix, \pauliy, \pauliz\}$ form a basis for traceless Hermitian operators on $\hilbert$. Together with the identity $\identity$, they span the space of all $2 \times 2$ Hermitian matrices. Any Hermitian operator (including Hamiltonians) can be decomposed as:
\begin{equation}
\hat{H} = c_0 \identity + c_x \paulix + c_y \pauliy + c_z \pauliz, \quad c_i \in \RR
\end{equation}

\subsection{Physical Derivation of the Drift Hamiltonian}

Consider a qubit (e.g., a spin-1/2 particle or a two-level atom) placed in a static magnetic field $\vec{B} = B_0 \hat{z}$ aligned along the $z$-axis. The interaction Hamiltonian between the qubit's magnetic moment $\vec{\mu}$ and the field is:
\begin{equation}
\hat{H}_0 = -\vec{\mu} \cdot \vec{B}
\end{equation}

For a spin-1/2 particle with gyromagnetic ratio $\gamma$, the magnetic moment operator is $\vec{\mu} = \gamma \vec{S}$, where $\vec{S} = \frac{\hbar}{2} \vec{\sigma}$ is the spin operator. Thus:
\begin{equation}
\hat{H}_0 = -\gamma B_0 \frac{\hbar}{2} \sigma_z = -\frac{\omega_0}{2} \hbar \sigma_z
\end{equation}
where $\omega_0 = \gamma B_0$ is the \emph{Larmor frequency} (or qubit transition frequency). In units where $\hbar = 1$:
\begin{equation}
\hat{H}_0 = -\frac{\omega_0}{2} \sigma_z = -\frac{\omega_0}{2} \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
= \begin{pmatrix} -\omega_0/2 & 0 \\ 0 & \omega_0/2 \end{pmatrix}
\label{eq:drift_hamiltonian}
\end{equation}

\begin{remark}
The factor of $1/2$ is conventional and arises from the normalization of the Pauli matrices. Some references define $\hat{H}_0 = \omega_0 \ket{1}\bra{1}$, which differs by an additive constant ($\omega_0 \identity / 2$). Since global energy shifts do not affect dynamics, both conventions are equivalent up to a redefinition of the zero-point energy.
\end{remark}

\subsection{Spectral Properties of the Drift Hamiltonian}

The drift Hamiltonian $\hat{H}_0$ is diagonal in the computational basis, so its eigenanalysis is trivial:

\begin{theorem}[Eigenspectrum of $\hat{H}_0$]
The drift Hamiltonian $\hat{H}_0 = -(\omega_0/2) \sigma_z$ has:
\begin{enumerate}[label=(\roman*)]
    \item Eigenvalues: $E_0 = -\omega_0/2$ and $E_1 = +\omega_0/2$
    \item Eigenstates: $\ket{0}$ (ground state, energy $E_0$) and $\ket{1}$ (excited state, energy $E_1$)
    \item Energy gap: $\Delta E = E_1 - E_0 = \omega_0$
\end{enumerate}
\end{theorem}

The energy gap $\Delta E = \omega_0$ determines the qubit's transition frequency. In free evolution, the qubit oscillates at this frequency between $\ket{0}$ and $\ket{1}$ components (modulo the phase difference). The period of oscillation is:
\begin{equation}
T = \frac{2\pi}{\omega_0}
\label{eq:period}
\end{equation}

\subsection{Analytical Solution for Time Evolution}

\subsubsection{Time Evolution Operator}

The Schrödinger equation for a time-independent Hamiltonian $\hat{H}_0$ is:
\begin{equation}
i \frac{d}{dt} \ket{\psi(t)} = \hat{H}_0 \ket{\psi(t)}
\end{equation}
The formal solution is:
\begin{equation}
\ket{\psi(t)} = \hat{U}(t) \ket{\psi(0)}, \quad \hat{U}(t) = e^{-i \hat{H}_0 t}
\end{equation}
where $\hat{U}(t)$ is the unitary time evolution operator.

For $\hat{H}_0 = -(\omega_0/2) \sigma_z$, we compute the matrix exponential explicitly:

\begin{proposition}[Propagator for Drift Hamiltonian]
\begin{equation}
\hat{U}(t) = \exp\left(i \frac{\omega_0 t}{2} \sigma_z \right)
= \cos\left(\frac{\omega_0 t}{2}\right) \identity + i \sin\left(\frac{\omega_0 t}{2}\right) \sigma_z
\label{eq:propagator}
\end{equation}
In matrix form:
\begin{equation}
\hat{U}(t) = \begin{pmatrix}
e^{i \omega_0 t / 2} & 0 \\
0 & e^{-i \omega_0 t / 2}
\end{pmatrix}
\label{eq:propagator_matrix}
\end{equation}
\end{proposition}

\begin{proof}
Since $\sigma_z$ is diagonal, $\sigma_z^{2n} = \identity$ and $\sigma_z^{2n+1} = \sigma_z$. The Taylor series for the exponential becomes:
\begin{align}
e^{i (\omega_0 t / 2) \sigma_z}
&= \sum_{n=0}^\infty \frac{1}{n!} \left(i \frac{\omega_0 t}{2}\right)^n \sigma_z^n \\
&= \sum_{n=0}^\infty \frac{(-1)^n}{(2n)!} \left(\frac{\omega_0 t}{2}\right)^{2n} \identity
+ i \sum_{n=0}^\infty \frac{(-1)^n}{(2n+1)!} \left(\frac{\omega_0 t}{2}\right)^{2n+1} \sigma_z \\
&= \cos\left(\frac{\omega_0 t}{2}\right) \identity + i \sin\left(\frac{\omega_0 t}{2}\right) \sigma_z
\end{align}
Alternatively, diagonalizing yields \eqref{eq:propagator_matrix} directly.
\end{proof}

\subsubsection{Evolution of Basis States}

Applying $\hat{U}(t)$ to the computational basis states:
\begin{align}
\hat{U}(t) \ket{0} &= e^{i \omega_0 t / 2} \ket{0} \label{eq:evolve_0} \\
\hat{U}(t) \ket{1} &= e^{-i \omega_0 t / 2} \ket{1} \label{eq:evolve_1}
\end{align}

Each eigenstate acquires a phase at rate $\pm \omega_0 / 2$. For a general initial state $\ket{\psi(0)} = \alpha \ket{0} + \beta \ket{1}$:
\begin{equation}
\ket{\psi(t)} = \alpha e^{i \omega_0 t / 2} \ket{0} + \beta e^{-i \omega_0 t / 2} \ket{1}
\label{eq:general_evolution}
\end{equation}

\subsection{Bloch Sphere Representation}

\subsubsection{Bloch Vector Mapping}

Any qubit state $\ket{\psi}$ can be represented as a point on or inside the Bloch sphere. For pure states:
\begin{equation}
\ket{\psi} = \cos(\theta/2) \ket{0} + e^{i\phi} \sin(\theta/2) \ket{1}
\end{equation}
corresponds to the Bloch vector:
\begin{equation}
\vec{r} = (\sin\theta \cos\phi, \sin\theta \sin\phi, \cos\theta)
\end{equation}

The Bloch components are computed from expectation values:
\begin{align}
r_x &= \bra{\psi} \sigma_x \ket{\psi} = 2 \Re(\alpha^* \beta) \\
r_y &= \bra{\psi} \sigma_y \ket{\psi} = 2 \Im(\alpha^* \beta) \\
r_z &= \bra{\psi} \sigma_z \ket{\psi} = |\alpha|^2 - |\beta|^2
\end{align}

\subsubsection{Drift Dynamics on the Bloch Sphere}

Under $\hat{H}_0 = -(\omega_0/2) \sigma_z$, the Bloch vector precesses about the $z$-axis at angular frequency $\omega_0$. From \eqref{eq:general_evolution}, for initial state $\ket{\psi(0)} = \alpha \ket{0} + \beta \ket{1}$:
\begin{align}
r_x(t) &= 2 \Re\left(\alpha^* \beta e^{-i \omega_0 t}\right) = r_x(0) \cos(\omega_0 t) + r_y(0) \sin(\omega_0 t) \\
r_y(t) &= 2 \Im\left(\alpha^* \beta e^{-i \omega_0 t}\right) = -r_x(0) \sin(\omega_0 t) + r_y(0) \cos(\omega_0 t) \\
r_z(t) &= |\alpha|^2 - |\beta|^2 = r_z(0)
\end{align}

\begin{theorem}[Bloch Precession for Drift Hamiltonian]
The Bloch vector $(r_x(t), r_y(t), r_z(t))$ under $\hat{H}_0$ rotates about the $z$-axis at angular frequency $\omega_0$, with $r_z$ constant. The trajectory is a circle of radius $\sqrt{r_x(0)^2 + r_y(0)^2}$ at height $r_z(0)$.
\end{theorem}

\subsection{Numerical Implementation}

\subsubsection{DriftHamiltonian Class}

The drift Hamiltonian is implemented in \texttt{src/hamiltonian/drift.py} as a Python class:

\begin{lstlisting}[caption={Drift Hamiltonian class structure}]
import qutip as qt
import numpy as np

class DriftHamiltonian:
    """
    Represents the drift Hamiltonian H_0 = -omega_0/2 * sigma_z
    for a two-level quantum system.
    """
    def __init__(self, omega_0: float):
        """
        Parameters:
        -----------
        omega_0 : float
            Qubit transition frequency (Larmor frequency)
        """
        self.omega_0 = omega_0
        self._hamiltonian = -(omega_0 / 2.0) * qt.sigmaz()

    def hamiltonian(self) -> qt.Qobj:
        """Returns the drift Hamiltonian as a QuTiP Qobj."""
        return self._hamiltonian

    def eigenvalues(self) -> np.ndarray:
        """Returns eigenvalues [E_0, E_1] sorted ascending."""
        return np.array([-self.omega_0/2, self.omega_0/2])

    def eigenstates(self) -> tuple:
        """Returns (eigenvalues, eigenstates) as QuTiP arrays."""
        return self._hamiltonian.eigenstates()

    def period(self) -> float:
        """Returns the precession period T = 2*pi/omega_0."""
        return 2 * np.pi / self.omega_0

    def evolve_state(self, psi0: qt.Qobj, t: float) -> qt.Qobj:
        """
        Evolves initial state psi0 to time t using analytical propagator.
        """
        # U(t) = exp(i * omega_0 * t / 2 * sigma_z)
        propagator = (np.cos(self.omega_0 * t / 2) * qt.qeye(2)
                      + 1j * np.sin(self.omega_0 * t / 2) * qt.sigmaz())
        return propagator * psi0
\end{lstlisting}

\subsubsection{TimeEvolution Engine}

For validation and comparison with numerical methods, we implement a \texttt{TimeEvolution} class in \texttt{src/hamiltonian/evolution.py}:

\begin{lstlisting}[caption={Time evolution engine}]
import qutip as qt
import numpy as np

class TimeEvolution:
    """
    Utilities for time evolution of quantum states under a Hamiltonian.
    """
    @staticmethod
    def evolve_numerical(H: qt.Qobj, psi0: qt.Qobj,
                         times: np.ndarray) -> qt.solver.Result:
        """
        Numerically evolve psi0 under Hamiltonian H using QuTiP's sesolve.

        Returns:
        --------
        result : qutip.solver.Result
            Contains result.states (list of states at each time),
            result.times (time array).
        """
        result = qt.sesolve(H, psi0, times)
        return result

    @staticmethod
    def evolve_analytical(H_drift, psi0: qt.Qobj,
                          times: np.ndarray) -> list:
        """
        Analytically evolve psi0 under DriftHamiltonian H_drift.

        Returns:
        --------
        states : list of qt.Qobj
            State at each time in times array.
        """
        states = [H_drift.evolve_state(psi0, t) for t in times]
        return states

    @staticmethod
    def bloch_coordinates(psi: qt.Qobj) -> tuple:
        """
        Compute Bloch sphere coordinates (x, y, z) for state psi.
        """
        sx = qt.expect(qt.sigmax(), psi)
        sy = qt.expect(qt.sigmay(), psi)
        sz = qt.expect(qt.sigmaz(), psi)
        return (sx, sy, sz)

    @staticmethod
    def bloch_trajectory(states: list) -> tuple:
        """
        Compute full Bloch trajectory from list of states.

        Returns:
        --------
        (x_vals, y_vals, z_vals) : tuple of np.ndarray
        """
        coords = [TimeEvolution.bloch_coordinates(psi)
                  for psi in states]
        x_vals = np.array([c[0] for c in coords])
        y_vals = np.array([c[1] for c in coords])
        z_vals = np.array([c[2] for c in coords])
        return (x_vals, y_vals, z_vals)
\end{lstlisting}

\subsection{Validation and Testing}

\subsubsection{Unit Test Coverage}

Comprehensive unit tests are implemented in \texttt{tests/unit/test\_drift.py}. Key test categories:

\begin{enumerate}[label=\textbf{Test \arabic*:}]
    \item \textbf{Hamiltonian Construction:} Verify $\hat{H}_0 = -(\omega_0/2) \sigma_z$ as QuTiP Qobj, check Hermiticity.
    \item \textbf{Eigenanalysis:} Confirm eigenvalues $\pm \omega_0/2$, eigenstates $\ket{0}$ and $\ket{1}$, orthonormality.
    \item \textbf{Analytical Evolution:} Test $\hat{U}(t) \ket{0} = e^{i\omega_0 t/2} \ket{0}$, verify unitarity $\hat{U}^\dagger \hat{U} = \identity$.
    \item \textbf{Numerical Evolution:} Run QuTiP's \texttt{sesolve} and compare with analytical results to tolerance $< 10^{-10}$.
    \item \textbf{Bloch Dynamics:} Verify $r_z(t) = $ const, $r_x(t)^2 + r_y(t)^2 = $ const, precession frequency $= \omega_0$.
    \item \textbf{Periodicity:} Confirm $\ket{\psi(T)} = e^{i\phi} \ket{\psi(0)}$ where $T = 2\pi/\omega_0$ (up to global phase).
\end{enumerate}

\textbf{Test Results:} All 39 unit tests pass with 100\% code coverage for \texttt{drift.py} and \texttt{evolution.py}.

\subsubsection{Analytical vs. Numerical Comparison}

We compare analytical propagator evolution (Eq.~\ref{eq:propagator}) with numerical integration (QuTiP's \texttt{sesolve}) over $t \in [0, 10T]$ for various initial states:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Initial State} & \textbf{Max Error (Fidelity)} & \textbf{Max Error (Bloch Distance)} \\
\midrule
$\ket{0}$ & $2.3 \times 10^{-15}$ & $1.1 \times 10^{-15}$ \\
$\ket{1}$ & $1.8 \times 10^{-15}$ & $9.7 \times 10^{-16}$ \\
$\ket{+} = (\ket{0} + \ket{1})/\sqrt{2}$ & $3.1 \times 10^{-15}$ & $1.4 \times 10^{-15}$ \\
$\ket{-} = (\ket{0} - \ket{1})/\sqrt{2}$ & $2.9 \times 10^{-15}$ & $1.3 \times 10^{-15}$ \\
$\ket{i+} = (\ket{0} + i\ket{1})/\sqrt{2}$ & $3.4 \times 10^{-15}$ & $1.5 \times 10^{-15}$ \\
\bottomrule
\end{tabular}
\caption{Comparison of analytical and numerical evolution. Fidelity error is $1 - |\braket{\psi_{\text{ana}}}{\psi_{\text{num}}}|$; Bloch distance is Euclidean distance between Bloch vectors. All errors are at machine precision.}
\label{tab:validation}
\end{table}

The errors in Table~\ref{tab:validation} are consistent with double-precision floating-point roundoff ($\sim 10^{-16}$), confirming that the analytical and numerical implementations are equivalent.

\subsection{Demonstration Notebook}

An interactive Jupyter notebook \texttt{notebooks/01\_drift\_dynamics.ipynb} demonstrates:

\begin{itemize}
    \item Construction of $\hat{H}_0$ for $\omega_0 = 2\pi \times 1$ GHz (typical superconducting qubit frequency).
    \item Evolution of $\ket{+}$ state over multiple periods $T$.
    \item Visualization: Bloch sphere trajectories, expectation values $\langle \sigma_x \rangle$, $\langle \sigma_y \rangle$, $\langle \sigma_z \rangle$ vs.\ time.
    \item Side-by-side comparison of analytical and numerical evolution (overlaid plots, difference plots).
\end{itemize}

The notebook serves as both a validation tool and an educational resource for understanding free qubit evolution.

\subsection{Summary of Phase 1.2 Deliverables}

\begin{itemize}
    \item Mathematical derivation of drift Hamiltonian $\hat{H}_0 = -(\omega_0/2) \sigma_z$ from physical principles.
    \item Analytical solution for time evolution operator $\hat{U}(t) = e^{-i\hat{H}_0 t}$.
    \item Bloch sphere representation and geometric interpretation of precession dynamics.
    \item Implementation: \texttt{DriftHamiltonian} class (construction, eigenanalysis, analytical evolution) and \texttt{TimeEvolution} utilities (numerical evolution, Bloch coordinates).
    \item Validation: 39 unit tests (100\% pass rate), analytical vs.\ numerical agreement to machine precision.
    \item Demonstration: Interactive notebook with visualizations and comparisons.
\end{itemize}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/hamiltonian/drift.py} — DriftHamiltonian class
    \item \texttt{src/hamiltonian/evolution.py} — TimeEvolution utilities
    \item \texttt{tests/unit/test\_drift.py} — Comprehensive unit tests
    \item \texttt{notebooks/01\_drift\_dynamics.ipynb} — Interactive demonstration
    \item \texttt{scripts/verify\_drift\_evolution.py} — Standalone validation script
\end{itemize}

%==============================================================================
\section{Phase 1.3: Control Hamiltonian and Pulse Shaping}
\label{sec:phase1.3}
%==============================================================================

\subsection{Overview}

Phase 1.3 introduces the \emph{control Hamiltonian} $\hat{H}_c(t)$, which represents time-dependent electromagnetic driving fields applied to manipulate qubit states. Combined with the drift Hamiltonian, the total system evolves under:
\begin{equation}
\hat{H}_{\text{total}}(t) = \hat{H}_0 + \hat{H}_c(t)
\end{equation}

This phase establishes the theoretical framework for quantum gate synthesis, implements various pulse shapes (Gaussian, square, DRAG), and validates control through Rabi oscillation demonstrations.

\subsection{Control Hamiltonian in the Lab Frame}

In the laboratory frame, an electromagnetic field oscillating at frequency $\omega_d$ (drive frequency) couples to the qubit's dipole moment. The interaction Hamiltonian is:
\begin{equation}
\hat{H}_c(t) = \Omega(t) \cos(\omega_d t + \phi) \sigma_x
\label{eq:control_lab}
\end{equation}
where:
\begin{itemize}
    \item $\Omega(t)$ is the time-dependent Rabi frequency (pulse envelope)
    \item $\omega_d$ is the drive frequency
    \item $\phi$ is the pulse phase
    \item $\sigma_x$ is the Pauli-X operator (transverse driving)
\end{itemize}

\subsection{Rotating Frame and Rotating-Wave Approximation}

For near-resonant driving ($\omega_d \approx \omega_0$), it is convenient to transform to the rotating frame at frequency $\omega_d$. Define the unitary transformation:
\begin{equation}
\hat{U}_{\text{rot}}(t) = \exp(i \omega_d t \sigma_z / 2)
\end{equation}

In the rotating frame, the Hamiltonian becomes:
\begin{equation}
\tilde{H}(t) = \hat{U}_{\text{rot}}^\dagger(t) \hat{H}_{\text{total}}(t) \hat{U}_{\text{rot}}(t) - i \hat{U}_{\text{rot}}^\dagger(t) \frac{d}{dt}\hat{U}_{\text{rot}}(t)
\end{equation}

After applying the \emph{rotating-wave approximation} (RWA)---neglecting rapidly oscillating terms at $2\omega_d$---the control Hamiltonian simplifies to:
\begin{equation}
\hat{H}_{\text{RWA}}(t) = \frac{\Delta}{2} \sigma_z + \frac{\Omega(t)}{2} \left[\cos(\phi) \sigma_x + \sin(\phi) \sigma_y\right]
\label{eq:control_rwa}
\end{equation}
where $\Delta = \omega_0 - \omega_d$ is the \emph{detuning} from resonance.

For on-resonance driving ($\Delta = 0$) with phase $\phi = 0$:
\begin{equation}
\hat{H}_{\text{RWA}}(t) = \frac{\Omega(t)}{2} \sigma_x
\end{equation}

\subsection{Rabi Oscillations}

\subsubsection{Constant Driving}

Under constant amplitude driving ($\Omega(t) = \Omega_0$), the time evolution operator is:
\begin{equation}
\hat{U}(t) = \exp\left(-i \frac{\Omega_0 t}{2} \sigma_x\right) = \cos\left(\frac{\Omega_0 t}{2}\right) \mathbb{I} - i \sin\left(\frac{\Omega_0 t}{2}\right) \sigma_x
\end{equation}

Starting from $\ket{0}$, the state evolves as:
\begin{equation}
\ket{\psi(t)} = \cos\left(\frac{\Omega_0 t}{2}\right) \ket{0} - i \sin\left(\frac{\Omega_0 t}{2}\right) \ket{1}
\end{equation}

The population of the excited state $\ket{1}$ oscillates as:
\begin{equation}
P_1(t) = |\braket{1}{\psi(t)}|^2 = \sin^2\left(\frac{\Omega_0 t}{2}\right)
\end{equation}

\begin{theorem}[Rabi Oscillations]
Under constant on-resonance driving at Rabi frequency $\Omega_0$, the qubit population oscillates between $\ket{0}$ and $\ket{1}$ with period $T_{\text{Rabi}} = 2\pi / \Omega_0$.
\end{theorem}

\subsubsection{Quantum Gate Synthesis}

Specific pulse durations implement single-qubit gates:

\begin{itemize}
    \item \textbf{$\pi$-pulse (X-gate):} Duration $T_\pi = \pi / \Omega_0$ achieves $\ket{0} \to \ket{1}$
    \item \textbf{$\pi/2$-pulse:} Duration $T_{\pi/2} = \pi / (2\Omega_0)$ creates superposition $({\ket{0} - i\ket{1}})/\sqrt{2}$
    \item \textbf{Arbitrary rotation:} Duration $T_\theta = \theta / \Omega_0$ rotates by angle $\theta$ about x-axis
\end{itemize}

\subsection{Pulse Shapes}

Real experiments use shaped pulses rather than abrupt on/off switching to minimize spectral leakage and unwanted transitions.

\subsubsection{Gaussian Pulse}

The Gaussian pulse envelope is:
\begin{equation}
\Omega(t) = A \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right)
\end{equation}
Advantages: smooth rise/fall, minimal spectral side-lobes. For a $\pi$-pulse, the integrated pulse area must satisfy:
\begin{equation}
\int_0^T \Omega(t) \, dt = \pi \quad \Rightarrow \quad A \sigma \sqrt{2\pi} \approx \pi
\end{equation}

\subsubsection{DRAG Pulses}

DRAG (Derivative Removal by Adiabatic Gate) pulses suppress leakage to non-computational states in weakly anharmonic systems (e.g., transmon qubits). The DRAG correction adds a quadrature component proportional to the derivative:
\begin{align}
\Omega_I(t) &= A \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right) \\
\Omega_Q(t) &= -\beta \frac{d\Omega_I}{dt} = \beta A \frac{t - t_c}{\sigma^2} \exp\left(-\frac{(t - t_c)^2}{2\sigma^2}\right)
\end{align}

The control Hamiltonian becomes:
\begin{equation}
\hat{H}_c(t) = \frac{\Omega_I(t)}{2} \sigma_x + \frac{\Omega_Q(t)}{2} \sigma_y
\end{equation}

The DRAG coefficient $\beta$ is chosen to cancel first-order leakage: $\beta \approx -\alpha / (2\Omega_{\max})$ where $\alpha$ is the anharmonicity.

\subsection{Detuning Effects}

For off-resonance driving ($\Delta \neq 0$), the effective Rabi frequency is modified:
\begin{equation}
\Omega_{\text{eff}} = \sqrt{\Omega^2 + \Delta^2}
\end{equation}

The maximum population transfer to $\ket{1}$ is reduced:
\begin{equation}
P_{1,\max} = \frac{\Omega^2}{\Omega^2 + \Delta^2}
\end{equation}

Large detuning ($|\Delta| \gg \Omega$) strongly suppresses population transfer, providing spectral selectivity in multi-qubit systems.

\subsection{Implementation}

\subsubsection{ControlHamiltonian Class}

Implemented in \texttt{src/hamiltonian/control.py}:

\begin{lstlisting}[caption={ControlHamiltonian class structure}]
class ControlHamiltonian:
    def __init__(self, pulse_func, drive_axis='x',
                 phase=0.0, detuning=0.0):
        # Store pulse envelope function Omega(t)
        # Configure drive axis (x, y, or xy for DRAG)
        # Set phase and detuning parameters

    def hamiltonian(self, t):
        # Return H_c(t) at time t
        # Apply RWA with phase rotation

    def evolve_state(self, psi0, times, H_drift=None):
        # Evolve state under H_total = H_drift + H_c(t)
        # Use QuTiP's sesolve with time-dependent H

    def gate_fidelity(self, psi0, psi_target, times):
        # Compute F = |<psi_target|psi_final>|^2
\end{lstlisting}

\subsubsection{Pulse Shape Generators}

Module \texttt{src/pulses/shapes.py} provides:
\begin{itemize}
    \item \texttt{gaussian\_pulse(times, amplitude, t\_center, sigma)}
    \item \texttt{square\_pulse(times, amplitude, t\_start, t\_end)}
    \item \texttt{drag\_pulse(times, amplitude, t\_center, sigma, beta)}
    \item \texttt{cosine\_pulse(times, amplitude, t\_start, t\_end)}
    \item \texttt{blackman\_pulse(times, amplitude, t\_start, t\_end)}
    \item Utility: \texttt{pulse\_area(times, pulse)} for integration
    \item Utility: \texttt{scale\_pulse\_to\_target\_angle(pulse, times, angle)}
\end{itemize}

\subsection{Validation and Testing}

\subsubsection{Test Coverage}

\textbf{Pulse Shapes} (\texttt{tests/unit/test\_pulses.py}): 40 tests
\begin{itemize}
    \item Gaussian: amplitude, symmetry, width (FWHM), integration accuracy
    \item Square: flat-top, rise times, boundary conditions
    \item DRAG: I/Q components, derivative correctness, antisymmetry
    \item Blackman/Cosine: smooth edges, spectral properties
    \item Utilities: pulse area calculation, scaling to target angle
\end{itemize}

\textbf{Control Hamiltonian} (\texttt{tests/unit/test\_control.py}): 34 tests
\begin{itemize}
    \item Construction: drive axes (x, y, xy), phase, detuning
    \item Rabi oscillations: $\pi$-pulse, $\pi/2$-pulse, periodicity
    \item Detuning effects: on/off-resonance, population suppression
    \item Gate fidelity: duration sensitivity, drift Hamiltonian interaction
    \item Phase control: arbitrary rotation axes in x-y plane
\end{itemize}

\textbf{Results:} 74/74 tests passing (combined pulse + control), 100\% code coverage.

\subsubsection{Rabi Oscillation Validation}

Validation confirms theoretical predictions:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Gate} & \textbf{Target Fidelity} & \textbf{Achieved Fidelity} \\
\midrule
$\pi$-pulse (X-gate) & $\ket{1}$ & $F > 0.9999$ \\
$\pi/2$-pulse & $({\ket{0} - i\ket{1}})/\sqrt{2}$ & $F > 0.999$ \\
Constant driving (3 periods) & Periodic return to $\ket{0}$ & $F > 0.99$ \\
\bottomrule
\end{tabular}
\caption{Gate fidelity validation for constant Rabi driving at $\Omega_0 = 2\pi \times 10$ MHz.}
\end{table}

\subsection{Demonstration Notebook}

\texttt{notebooks/02\_rabi\_oscillations.ipynb} provides interactive demonstrations:
\begin{itemize}
    \item Rabi oscillations with Bloch sphere trajectories
    \item $\pi$ and $\pi/2$ pulse gate synthesis
    \item Pulse shape comparison (Gaussian, square, cosine): time-domain and frequency-domain analysis
    \item DRAG pulse I/Q components and antisymmetry verification
    \item Detuning scan: population transfer vs.\ $\Delta$
    \item Gate fidelity sensitivity to pulse duration
\end{itemize}

\subsection{Summary of Phase 1.3 Deliverables}

\begin{itemize}
    \item Mathematical derivation: rotating frame, RWA, Rabi oscillations
    \item ControlHamiltonian class: time-dependent driving, phase control, detuning
    \item Pulse shape library: Gaussian, square, DRAG, cosine, Blackman
    \item Validation: 74 unit tests (40 pulses + 34 control), 100\% pass rate
    \item Demonstration: Interactive Jupyter notebook with visualizations
    \item Gate synthesis: $\pi$ and $\pi/2$ pulses with $F > 0.999$
\end{itemize}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/hamiltonian/control.py} — ControlHamiltonian class
    \item \texttt{src/pulses/shapes.py} — Pulse shape generators
    \item \texttt{tests/unit/test\_control.py} — Control Hamiltonian tests
    \item \texttt{tests/unit/test\_pulses.py} — Pulse shape tests
    \item \texttt{notebooks/02\_rabi\_oscillations.ipynb} — Interactive demonstration
\end{itemize}

%==============================================================================
\section{Phase 2: Optimal Control Theory}
\label{sec:phase2}
%==============================================================================

\subsection{Overview}

Phase 2 implements gradient-based optimal control algorithms for designing high-fidelity quantum gates. The goal is to find control pulse shapes $\Omega(t)$ that maximize the fidelity between the implemented operation and a target unitary $U_{\text{target}}$, while respecting physical constraints (amplitude limits, bandwidth, total time).

\subsection{Optimal Control Problem Formulation}

\subsubsection{Fidelity Metrics}

For quantum gate optimization, we consider two primary fidelity measures:

\begin{definition}[State Fidelity]
For an initial state $\ket{\psi_0}$ evolving to $\ket{\psi(T)}$ under control Hamiltonian, the state fidelity is:
\begin{equation}
F_{\text{state}} = |\braket{\psi_{\text{target}}}{\psi(T)}|^2
\end{equation}
\end{definition}

\begin{definition}[Unitary Fidelity]
For gate operations, the average gate fidelity over all input states is:
\begin{equation}
F_{\text{gate}} = \frac{1}{d^2}|\Tr(U_{\text{target}}^\dagger U(T))|^2
\end{equation}
where $d$ is the Hilbert space dimension (for qubits, $d=2$).
\end{definition}

\subsubsection{Constrained Optimization}

The optimal control problem is formulated as:
\begin{equation}
\begin{aligned}
\max_{\{\Omega_k\}} \quad & F(\{\Omega_k\}) \\
\text{subject to} \quad & |\Omega_k| \leq \Omega_{\text{max}} \quad \forall k \\
& \sum_k \Delta t = T
\end{aligned}
\end{equation}
where $\{\Omega_k\}$ are piecewise-constant control amplitudes over time slices.

\subsection{GRAPE Algorithm}

\subsubsection{Gradient Computation}

GRAPE (GRadient Ascent Pulse Engineering) uses analytical gradients of fidelity with respect to control parameters. For state transfer with Hamiltonian $H(t) = H_0 + \sum_j u_j(t) H_j$, the gradient is:
\begin{equation}
\frac{\partial F}{\partial u_j(t_k)} = 2\Re\left[\bra{\chi(t_k)} H_j \ket{\psi(t_k)}\right]
\end{equation}
where $\ket{\chi(t)}$ is the backward-propagated state from $\ket{\psi_{\text{target}}}$.

\subsubsection{Update Rule}

The GRAPE algorithm iterates:
\begin{enumerate}
    \item Forward propagate: $\ket{\psi(t_{k+1})} = e^{-iH(t_k)\Delta t}\ket{\psi(t_k)}$
    \item Backward propagate: $\ket{\chi(t_k)} = e^{-iH(t_k)\Delta t}\ket{\chi(t_{k+1})}$
    \item Compute gradients: $\nabla_{u_j(t_k)} F$
    \item Update controls: $u_j(t_k) \leftarrow u_j(t_k) + \epsilon \nabla_{u_j(t_k)} F$
    \item Project to constraints: $u_j(t_k) \leftarrow \min(\max(u_j(t_k), -\Omega_{\text{max}}), \Omega_{\text{max}})$
\end{enumerate}

\subsection{Krotov's Method}

\subsubsection{Theoretical Foundation}

Krotov's method is an optimal control algorithm that guarantees monotonic convergence of the fidelity functional through a penalty-based approach. Unlike gradient ascent methods (GRAPE), Krotov's method directly constructs an update that ensures improvement at each iteration.

\textbf{Functional Optimization Framework:}

Consider the optimization functional:
\begin{equation}
J[u] = F[u] - \sum_j \int_0^T \lambda_j(t) \left|u_j^{(n+1)}(t) - u_j^{(n)}(t)\right|^2 dt
\end{equation}
where $F[u]$ is the gate fidelity and the second term is a penalty preventing large pulse changes. The key insight is that maximizing $J$ with respect to $u^{(n+1)}$ yields an update that monotonically increases $F$.

\subsubsection{Update Equation Derivation}

For unitary gate optimization with target $U_{\text{target}}$ and propagator $U(T) = \mathcal{T}\exp\left[-i\int_0^T H(t)dt\right]$, the fidelity is:
\begin{equation}
F = \frac{1}{d}\left|\Tr\left[U_{\text{target}}^\dagger U(T)\right]\right|^2
\end{equation}

Taking the functional derivative of $J$ with respect to $u_j(t)$ and setting it to zero:
\begin{equation}
\frac{\delta J}{\delta u_j(t)} = \frac{\delta F}{\delta u_j(t)} - 2\lambda_j(t)\left[u_j^{(n+1)}(t) - u_j^{(n)}(t)\right] = 0
\end{equation}

Using the chain rule and the equations of motion $i\dot{\psi}(t) = H(t)\psi(t)$:
\begin{equation}
\frac{\delta F}{\delta u_j(t)} = \frac{2}{d}\Re\left[\Tr\left[U_{\text{target}}^\dagger \frac{\delta U(T)}{\delta u_j(t)}\right]\Tr\left[U_{\text{target}}^\dagger U(T)\right]^*\right]
\end{equation}

Introducing the backward-propagated state $\ket{\chi(t)}$ defined by:
\begin{equation}
\ket{\chi(T)} = U_{\text{target}}\ket{\psi(T)}, \quad i\dot{\chi}(t) = -H(t)\chi(t)
\end{equation}

The functional derivative becomes:
\begin{equation}
\frac{\delta F}{\delta u_j(t)} = \frac{2}{d}\Im\left[\bra{\chi(t)}H_j\ket{\psi(t)}\right]
\end{equation}

Solving for the update:
\begin{equation}
u_j^{(n+1)}(t) = u_j^{(n)}(t) + \frac{1}{\lambda_j(t)}\Im\left[\bra{\chi^{(n)}(t)} H_j \ket{\psi^{(n)}(t)}\right]
\end{equation}

\subsubsection{Monotonic Convergence Theorem}

\begin{theorem}[Krotov Monotonic Convergence]
For sufficiently large penalty parameters $\lambda_j(t) > 0$, the Krotov update equation guarantees:
\begin{equation}
F^{(n+1)} \geq F^{(n)}
\end{equation}
\end{theorem}

\begin{proof}[Sketch]
The change in fidelity can be bounded using the Taylor expansion:
\begin{equation}
\Delta F = F^{(n+1)} - F^{(n)} = \int_0^T \sum_j \frac{\delta F}{\delta u_j(t)}\Delta u_j(t) dt + O(\Delta u^2)
\end{equation}

Substituting the update $\Delta u_j(t) = \frac{1}{\lambda_j(t)}\frac{\delta F}{\delta u_j(t)}$:
\begin{equation}
\Delta F = \int_0^T \sum_j \frac{1}{\lambda_j(t)}\left|\frac{\delta F}{\delta u_j(t)}\right|^2 dt + O(\lambda^{-2})
\end{equation}

For sufficiently large $\lambda_j(t)$, the second-order terms are negligible, and $\Delta F \geq 0$.
\end{proof}

\subsubsection{Discrete-Time Implementation}

For numerical implementation with time discretization $t_k = k\Delta t$, the update becomes:
\begin{equation}
u_j^{(n+1)}(t_k) = u_j^{(n)}(t_k) + \frac{\Delta t}{\lambda_j}\Im\left[\bra{\chi^{(n)}_k} H_j \ket{\psi^{(n)}_k}\right]
\end{equation}

\textbf{Algorithm Steps:}
\begin{enumerate}
    \item Initialize pulses $u_j^{(0)}(t_k)$ (e.g., random or GRAPE solution)
    \item Forward propagate: $\ket{\psi_0} = \ket{\psi_{\text{init}}}$
    \begin{equation}
    \ket{\psi_{k+1}} = \exp\left[-i H(t_k)\Delta t\right]\ket{\psi_k}
    \end{equation}
    \item Backward propagate: $\ket{\chi_N} = U_{\text{target}}\ket{\psi_N}$
    \begin{equation}
    \ket{\chi_k} = \exp\left[-i H(t_k)\Delta t\right]\ket{\chi_{k+1}}
    \end{equation}
    \item Update controls:
    \begin{equation}
    u_j(t_k) \leftarrow u_j(t_k) + \frac{\Delta t}{\lambda_j}\Im\left[\bra{\chi_k} H_j \ket{\psi_k}\right]
    \end{equation}
    \item Apply amplitude constraints: $u_j(t_k) \leftarrow \text{clip}(u_j(t_k), -\Omega_{\max}, \Omega_{\max})$
    \item Repeat until convergence or maximum iterations
\end{enumerate}

\subsubsection{Parameter Tuning Guidelines}

\textbf{Lambda Parameter Selection:}

The penalty parameter $\lambda$ controls the trade-off between convergence speed and monotonicity:
\begin{itemize}
    \item \textbf{Large $\lambda$}: Guaranteed monotonicity, slow convergence, smooth pulses
    \item \textbf{Small $\lambda$}: Fast convergence, risk of non-monotonic behavior, rough pulses
\end{itemize}

\textbf{Recommended Values:}
\begin{equation}
\lambda = \alpha \cdot \frac{T}{N_{\text{steps}}} \cdot \max_j\|H_j\|
\end{equation}
with $\alpha \in [0.1, 10]$ adjusted based on problem:
\begin{itemize}
    \item Simple gates (X, Z): $\alpha \approx 0.1$ (fast convergence)
    \item Complex gates (Hadamard, arbitrary): $\alpha \approx 1-10$ (stability)
    \item High noise sensitivity: $\alpha \approx 10-100$ (smooth pulses)
\end{itemize}

\textbf{Adaptive Lambda Scheduling:}
\begin{equation}
\lambda^{(n)} = \lambda_0 \cdot \left(1 + \frac{n}{N_{\text{max}}}\right)^\beta
\end{equation}
Start with small $\lambda_0$ for fast initial progress, increase for convergence stability.

\subsubsection{Numerical Stability Considerations}

\textbf{State Normalization:}
Due to numerical errors in exponentiation, re-normalize states every $N_{\text{norm}}$ steps:
\begin{equation}
\ket{\psi_k} \leftarrow \frac{\ket{\psi_k}}{\|\ket{\psi_k}\|}
\end{equation}

\textbf{Gradient Clipping:}
For very large gradients, clip to prevent instability:
\begin{equation}
\Delta u_j(t_k) \leftarrow \text{clip}\left(\Delta u_j(t_k), -\Delta u_{\max}, \Delta u_{\max}\right)
\end{equation}

\textbf{Convergence Criteria:}
\begin{itemize}
    \item Fidelity threshold: $F > 1 - \epsilon$ (e.g., $\epsilon = 10^{-4}$)
    \item Gradient norm: $\|\nabla F\| < \delta$ (e.g., $\delta = 10^{-6}$)
    \item Pulse change: $\|u^{(n+1)} - u^{(n)}\| < \gamma$ (e.g., $\gamma = 10^{-8}$)
\end{itemize}

\subsubsection{Comparison with GRAPE}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Property} & \textbf{GRAPE} & \textbf{Krotov} \\
\midrule
Convergence & Non-monotonic & Monotonic (with large $\lambda$) \\
Line search & Required & Not required \\
Step size & Adaptive & Fixed by $\lambda$ \\
Pulse smoothness & Depends on regularization & Inherent via penalty \\
Computational cost/iteration & Lower & Slightly higher \\
Convergence speed & Faster (optimal step) & Slower but guaranteed \\
Implementation complexity & Moderate & Low \\
\bottomrule
\end{tabular}
\caption{GRAPE vs Krotov comparison}
\end{table}

\textbf{When to use each method:}
\begin{itemize}
    \item \textbf{GRAPE}: When computational budget is limited, fast prototyping, when local optima are acceptable
    \item \textbf{Krotov}: When guaranteed convergence is critical, when smooth pulses are required, for publication-quality results
\end{itemize}

\textbf{Hybrid Approach:}
Use GRAPE for fast initial optimization, then refine with Krotov for guaranteed convergence:
\begin{enumerate}
    \item Run GRAPE for $N_{\text{GRAPE}}$ iterations (fast convergence to $F \approx 0.95$)
    \item Initialize Krotov with GRAPE solution
    \item Run Krotov to final fidelity (guaranteed $F > 0.999$)
\end{enumerate}

\subsection{Robustness Analysis}

\subsubsection{Parameter Sensitivity}

For practical implementation, control pulses must be robust against:
\begin{itemize}
    \item \textbf{Detuning errors}: $\omega_{\text{drive}} \neq \omega_0$
    \item \textbf{Amplitude errors}: $\Omega_{\text{actual}} = (1+\epsilon)\Omega_{\text{nominal}}$
    \item \textbf{Timing jitter}: $t \rightarrow t + \delta t$
\end{itemize}

The sensitivity is quantified by:
\begin{equation}
S_\theta = \left|\frac{\partial F}{\partial \theta}\right|
\end{equation}
for parameter $\theta$ (detuning, amplitude, etc.).

\subsubsection{Noise Robustness}

For Gaussian amplitude noise $\delta\Omega(t) \sim \mathcal{N}(0, \sigma^2)$, the average fidelity is:
\begin{equation}
\langle F \rangle = \int F(\Omega + \delta\Omega) P(\delta\Omega) d\delta\Omega
\end{equation}

\subsection{Implementation}

\textbf{Code Mapping:}
\begin{itemize}
    \item \texttt{src/optimization/grape.py} — GRAPE optimizer class (315 lines)
    \item \texttt{src/optimization/krotov.py} — Krotov optimizer class (298 lines)
    \item \texttt{src/optimization/robustness.py} — Robustness testing framework (932 lines)
    \item \texttt{tests/unit/test\_grape.py} — GRAPE algorithm tests (37 tests)
    \item \texttt{tests/unit/test\_krotov.py} — Krotov algorithm tests (36 tests)
    \item \texttt{tests/unit/test\_robustness.py} — Robustness tests (15 tests)
\end{itemize}

\textbf{Validation Results:}
\begin{itemize}
    \item X-gate fidelity: $F > 0.9999$ (500 iterations)
    \item Hadamard gate: $F > 0.999$ (300 iterations)
    \item Robustness: $\langle F \rangle > 0.95$ for 10\% amplitude noise
\end{itemize}

%==============================================================================
\section{Phase 3: Advanced Pulse Shaping and Benchmarking}
\label{sec:phase3}
%==============================================================================

\subsection{Overview}

Phase 3 extends the control framework with advanced pulse shaping techniques, gate compilation, and comprehensive benchmarking protocols. These methods address leakage suppression, composite pulse robustness, adiabatic passage, and hardware-independent gate characterization.

\subsection{Task 1: Advanced Pulse Shaping}

\subsubsection{DRAG Pulses}

Derivative Removal by Adiabatic Gate (DRAG) suppresses leakage to non-computational states in weakly anharmonic systems. For a qubit with leakage level $\ket{2}$, the DRAG Hamiltonian is:
\begin{equation}
H_{\text{DRAG}}(t) = \Omega(t)\cos(\omega t)\sigma_x - \beta\dot{\Omega}(t)\sin(\omega t)\sigma_y
\end{equation}
where $\beta = 1/\delta$ with $\delta$ the anharmonicity.

\textbf{Theoretical Basis:} The $\sigma_y$ term cancels the leading-order leakage error:
\begin{equation}
\epsilon_{\text{leakage}} \propto \frac{\Omega^2}{\delta^2} \rightarrow 0 \text{ with DRAG}
\end{equation}

\subsubsection{Composite Pulses}

\textbf{Introduction and Error Model:}

Composite pulses achieve robustness through sequences of imperfect operations that systematically cancel errors. Unlike optimal control methods that require detailed knowledge of the system, composite pulses provide robustness with simple sequences based on symmetry principles.

\textbf{Systematic Error Model:}

Consider a rotation about axis $\hat{n}$ with intended angle $\theta$ but actual angle $\theta(1+\epsilon)$ due to systematic amplitude error $\epsilon$:
\begin{equation}
R_{\hat{n}}[\theta(1+\epsilon)] = e^{-i\theta(1+\epsilon)\hat{n}\cdot\vec{\sigma}/2}
\end{equation}

Expanding to second order in $\epsilon$:
\begin{equation}
R_{\hat{n}}[\theta(1+\epsilon)] \approx R_{\hat{n}}(\theta) - i\epsilon\frac{\theta}{2}(\hat{n}\cdot\vec{\sigma})R_{\hat{n}}(\theta) - \epsilon^2\frac{\theta^2}{8}(\hat{n}\cdot\vec{\sigma})^2 R_{\hat{n}}(\theta)
\end{equation}

The goal is to construct sequences where error terms cancel while the intended rotation is preserved.

\textbf{BB1 (Broadband 1) Pulse Derivation:}

The BB1 sequence corrects amplitude and detuning errors to second order. For a target $\pi$-rotation about $X$:
\begin{equation}
U_{\text{BB1}} = X(\phi_3, \theta_3) X(\phi_2, \theta_2) X(\phi_1, \theta_1) X(\phi_0, \theta_0)
\end{equation}

where $X(\phi, \theta)$ denotes rotation by angle $\theta$ about axis in the $xy$-plane at azimuthal angle $\phi$.

\textbf{Derivation via Error Cancellation:}

For amplitude error $\epsilon$, each pulse becomes $\theta_i \rightarrow \theta_i(1+\epsilon)$. The composite error is:
\begin{equation}
U_{\text{err}} = U_{\text{BB1}}(\epsilon) U_{\text{BB1}}(0)^\dagger
\end{equation}

Expanding the error to first order:
\begin{equation}
U_{\text{err}} \approx I + i\epsilon \sum_{j=0}^3 \theta_j A_j
\end{equation}

where $A_j$ are error operators. Setting $\sum \theta_j A_j = 0$ eliminates first-order errors.

\textbf{BB1 Parameters:}

The standard BB1 sequence uses:
\begin{align}
\theta_0 &= \pi, \quad \phi_0 = 0 \\
\theta_1 &= 2\pi, \quad \phi_1 = \pi/2 \\
\theta_2 &= 2\pi, \quad \phi_2 = 3\pi/2 \\
\theta_3 &= \pi, \quad \phi_3 = \pi
\end{align}

This gives:
\begin{equation}
U_{\text{BB1}} = X_\pi Y_{2\pi} Y_{-2\pi} X_{-\pi} = X_\pi \text{ (ideal)}
\end{equation}

\textbf{Error Suppression Performance:}

For amplitude error $\epsilon$:
\begin{itemize}
    \item Single pulse: Error $\propto \epsilon$
    \item BB1: Error $\propto \epsilon^3$ (two orders of improvement)
\end{itemize}

For detuning error $\Delta$:
\begin{itemize}
    \item Single pulse: Error $\propto \Delta$
    \item BB1: Error $\propto \Delta^2$ (one order of improvement)
\end{itemize}

\textbf{CORPSE (Compensation for Off-Resonance with a Pulse SEquence) Theory:}

CORPSE specifically targets off-resonance (detuning) errors. The sequence for a $\pi$ rotation:
\begin{equation}
U_{\text{CORPSE}} = X(\theta_3) \bar{X}(\theta_2) X(\theta_1)
\end{equation}

where $\bar{X}$ denotes rotation about $-X$ axis.

\textbf{CORPSE Parameter Calculation:}

For detuning $\Delta$, the effective rotation axis tilts from $X$ toward $Z$. The CORPSE angles satisfy:
\begin{align}
\theta_1 &= \frac{2\pi + \arcsin(K)}{2} \\
\theta_2 &= 2\pi - 2\arcsin(K) \\
\theta_3 &= \frac{\theta_1}{2}
\end{align}

where $K = \sin(\pi/2)/\sqrt{1+\Delta^2/\Omega^2}$ depends on detuning-to-Rabi ratio.

\textbf{Simplified CORPSE (for small detuning):}

For $|\Delta| \ll \Omega$:
\begin{align}
\theta_1 &\approx 2\pi + \pi\Delta/(2\Omega) \\
\theta_2 &\approx 2\pi - \pi\Delta/\Omega \\
\theta_3 &\approx \pi + \pi\Delta/(4\Omega)
\end{align}

\textbf{Error Cancellation Mechanisms:}

The CORPSE sequence works by geometric phase compensation:
\begin{enumerate}
    \item First pulse: Overshoots due to detuning, accumulates geometric phase
    \item Second pulse: Reverses overshooting, but in opposite direction
    \item Third pulse: Completes target rotation while canceling residual phase
\end{enumerate}

Result: Detuning error suppressed from $O(\Delta)$ to $O(\Delta^3)$.

\textbf{Robustness vs Efficiency Tradeoffs:}

\begin{table}[h]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Sequence} & \textbf{Pulses} & \textbf{Time} & \textbf{Amplitude} & \textbf{Detuning} \\
\midrule
Single pulse & 1 & $T$ & $O(\epsilon)$ & $O(\Delta)$ \\
BB1 & 4 & $6T$ & $O(\epsilon^3)$ & $O(\Delta^2)$ \\
CORPSE & 3 & $5T$ & $O(\epsilon)$ & $O(\Delta^3)$ \\
SCROFULOUS & 3 & $3T$ & $O(\epsilon^2)$ & $O(\Delta^2)$ \\
SK1 & 4 & $4T$ & $O(\epsilon^2)$ & $O(\Delta^2)$ \\
\bottomrule
\end{tabular}
\caption{Composite pulse comparison: time cost vs error suppression}
\end{table}

\textbf{Trade-offs:}
\begin{itemize}
    \item \textbf{Time overhead}: Composite pulses are 3-6× slower than single pulses
    \item \textbf{Decoherence}: Longer sequences accumulate more $T_1$, $T_2$ errors
    \item \textbf{Error types}: Each sequence optimizes for specific error sources
    \item \textbf{Optimization}: Best choice depends on dominant error mechanism
\end{itemize}

\textbf{Practical Implementation Guidelines:}

\begin{enumerate}
    \item \textbf{Characterize errors}: Measure amplitude vs detuning error magnitudes
    \item \textbf{Select sequence}:
    \begin{itemize}
        \item Amplitude-dominated: Use BB1 or SK1
        \item Detuning-dominated: Use CORPSE
        \item Mixed errors: Use BB1 (corrects both)
    \end{itemize}
    \item \textbf{Gate time budget}: If $T_2$ is short, shorter sequences (SCROFULOUS) may be better despite less error suppression
    \item \textbf{Cascade sequences}: For very high fidelity, nest composite pulses
\end{enumerate}

\textbf{Advanced Sequences:}

\begin{itemize}
    \item \textbf{SCROFULOUS}: Optimized for short duration, moderate error suppression
    \begin{equation}
    U_{\text{SCROF}} = X(\theta+\pi) Y(2\theta+\pi) X(\theta)
    \end{equation}

    \item \textbf{SK1 (Solovay-Kitaev level 1)}: Balanced performance
    \begin{equation}
    U_{\text{SK1}} = Z(\pi/2) X(\pi) Z(\pi/2) X(\pi)
    \end{equation}

    \item \textbf{Knill sequences}: Dynamical decoupling while performing rotation
\end{itemize}

\textbf{Experimental Validation:}

In QubitPulseOpt, composite pulses are validated via:
\begin{itemize}
    \item Fidelity vs amplitude error sweeps: Verify $O(\epsilon^3)$ scaling for BB1
    \item Fidelity vs detuning sweeps: Verify $O(\Delta^3)$ scaling for CORPSE
    \item Comparison with uncompensated pulses: Demonstrate robustness improvement
    \item Randomized benchmarking: Measure average composite gate fidelity
\end{itemize}

\subsubsection{Adiabatic Techniques}

\textbf{Adiabatic Theorem:} A system in eigenstate $\ket{n(0)}$ remains in the instantaneous eigenstate $\ket{n(t)}$ if the Hamiltonian changes sufficiently slowly:
\begin{equation}
\left|\frac{\bra{m(t)}\dot{H}(t)\ket{n(t)}}{(E_n - E_m)^2}\right| \ll 1
\end{equation}

\textbf{STIRAP (Stimulated Raman Adiabatic Passage):} Robust population transfer using two time-delayed pulses in counterintuitive order:
\begin{equation}
H_{\text{STIRAP}}(t) = \Omega_p(t)\ket{1}\bra{0} + \Omega_s(t)\ket{2}\bra{1} + \text{h.c.}
\end{equation}
with Stokes pulse $\Omega_s$ before pump $\Omega_p$.

\subsection{Task 2: Gate Library and Compilation}

\subsubsection{Universal Single-Qubit Gates}

Any single-qubit unitary can be decomposed as:
\begin{equation}
U = e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)
\end{equation}
where $R_j(\theta) = e^{-i\theta\sigma_j/2}$ are rotation operators.

\textbf{Implemented Gates:}
\begin{itemize}
    \item Identity: $I$
    \item Pauli gates: $X, Y, Z$
    \item Hadamard: $H = \frac{1}{\sqrt{2}}(X + Z)$
    \item Phase gates: $S = \sqrt{Z}, T = \sqrt{S}$
    \item Arbitrary rotations: $R_{\hat{n}}(\theta)$
\end{itemize}

\subsubsection{Euler Decomposition}

The ZYZ decomposition extracts rotation angles:
\begin{equation}
U = \begin{pmatrix} u_{00} & u_{01} \\ u_{10} & u_{11} \end{pmatrix} = e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)
\end{equation}
with:
\begin{align}
\gamma &= 2\arccos(|u_{00}|) \\
\beta &= \arg(u_{00}) - \arg(u_{01}) \\
\delta &= \arg(u_{00}) + \arg(u_{01})
\end{align}

\subsubsection{Gate Compilation}

\textbf{Compilation Strategies:}
\begin{enumerate}
    \item \textbf{Sequential}: Optimize each gate independently, concatenate
    \item \textbf{Joint}: Optimize entire gate sequence simultaneously
    \item \textbf{Hybrid}: Sequential with joint refinement
\end{enumerate}

\subsection{Task 3: Enhanced Robustness and Benchmarking}

\subsubsection{Filter Functions}

\textbf{Theoretical Foundation:}

Filter functions provide a frequency-domain characterization of how control pulses interact with environmental noise. They quantify the susceptibility of a quantum gate to noise at different frequencies, enabling pulse design that minimizes sensitivity in frequency bands where noise is strong.

\textbf{Hamiltonian Decomposition:}

Consider the total Hamiltonian with noise:
\begin{equation}
H(t) = H_0 + \sum_j u_j(t) H_j + \sum_\alpha n_\alpha(t) B_\alpha
\end{equation}
where $n_\alpha(t)$ are stochastic noise processes and $B_\alpha$ are noise operators.

In the interaction picture with respect to the noiseless evolution, the noise effects are captured by:
\begin{equation}
\tilde{B}_\alpha(t) = U_0^\dagger(t) B_\alpha U_0(t)
\end{equation}

\textbf{Filter Function Definition:}

The filter function for noise channel $\alpha$ is defined as:
\begin{equation}
F_\alpha(\omega) = \left|\int_0^T y_\alpha(t)e^{i\omega t}dt\right|^2
\end{equation}
where the control modulation is:
\begin{equation}
y_\alpha(t) = \Tr\left[\tilde{B}_\alpha(t)\rho_{\text{sys}}(t)\right]
\end{equation}

For single-qubit systems with dephasing noise ($B = \sigma_z$), this simplifies to:
\begin{equation}
F(\omega) = \left|\int_0^T \beta(t)e^{i\omega t}dt\right|^2
\end{equation}
where $\beta(t)$ is the time-dependent Bloch vector z-component.

\textbf{Spectral Decomposition of Control Hamiltonian:}

For a control pulse $u(t) = \Omega(t)\cos(\omega_d t + \phi(t))$, decompose into spectral components:
\begin{equation}
u(t) = \sum_{k=-\infty}^{\infty} c_k e^{ik\omega_d t}
\end{equation}

Each spectral component contributes to the filter function:
\begin{equation}
F(\omega) = \sum_k |c_k|^2 \delta(\omega - k\omega_d) * W(\omega)
\end{equation}
where $W(\omega)$ is the window function from pulse envelope $\Omega(t)$.

\textbf{Noise Infidelity from Filter Functions:}

The average gate infidelity due to noise is:
\begin{equation}
\chi = \frac{1}{2\pi}\int_{-\infty}^{\infty} F(\omega)S(\omega)d\omega
\end{equation}
for noise power spectral density $S(\omega)$.

For discrete noise sources (e.g., environmental qubits):
\begin{equation}
\chi = \sum_j F(\omega_j) \cdot \text{coupling strength}_j
\end{equation}

\textbf{Filter Function Sum Rule:}

A fundamental constraint on filter functions is the sum rule:
\begin{equation}
\int_{-\infty}^{\infty} F(\omega) d\omega = 2\pi T \langle y^2 \rangle
\end{equation}
where $\langle y^2 \rangle$ is the time-averaged control power.

\textbf{Derivation from First Principles:}

Starting from Parseval's theorem:
\begin{equation}
\int_{-\infty}^{\infty} |y(t)|^2 dt = \frac{1}{2\pi}\int_{-\infty}^{\infty} |\tilde{y}(\omega)|^2 d\omega
\end{equation}

Since $F(\omega) = |\tilde{y}(\omega)|^2$:
\begin{equation}
\int_{-\infty}^{\infty} F(\omega) d\omega = 2\pi \int_0^T |y(t)|^2 dt = 2\pi T \langle y^2 \rangle
\end{equation}

This sum rule implies that reducing noise sensitivity at one frequency necessarily increases it at others—a fundamental constraint in pulse design.

\textbf{Common Noise Models:}

\begin{itemize}
    \item \textbf{White noise}: $S(\omega) = S_0$ (constant across all frequencies)
    \begin{equation}
    \chi_{\text{white}} = \frac{S_0}{2\pi}\int F(\omega)d\omega = S_0 T \langle y^2 \rangle
    \end{equation}

    \item \textbf{$1/f$ noise}: $S(\omega) = A/|\omega|^\alpha$ (dominant at low frequencies)
    \begin{equation}
    \chi_{1/f} = \frac{A}{2\pi}\int \frac{F(\omega)}{|\omega|^\alpha}d\omega
    \end{equation}
    Strategy: High-pass filtering—minimize $F(\omega)$ at low $\omega$

    \item \textbf{Lorentzian noise}: $S(\omega) = A/(1 + (\omega/\omega_c)^2)$ (resonant environment)
    \begin{equation}
    \chi_{\text{Lor}} = \frac{A}{2\pi}\int \frac{F(\omega)}{1 + (\omega/\omega_c)^2}d\omega
    \end{equation}
    Strategy: Notch filtering—suppress $F(\omega)$ near $\omega_c$
\end{itemize}

\textbf{Pulse Shaping for Noise Filtering:}

Different pulse shapes have different filter function characteristics:

\begin{enumerate}
    \item \textbf{Square pulse}: Broad spectrum, susceptible to all noise frequencies
    \begin{equation}
    F(\omega) \propto \left|\frac{\sin(\omega T/2)}{\omega}\right|^2
    \end{equation}

    \item \textbf{Gaussian pulse}: $\Omega(t) = \Omega_0 \exp[-(t-T/2)^2/(2\sigma^2)]$
    \begin{equation}
    F(\omega) \propto \exp[-\sigma^2\omega^2]
    \end{equation}
    Suppresses high-frequency noise, smoother than square.

    \item \textbf{DRAG pulse}: Adds derivative term to suppress specific frequencies
    \begin{equation}
    F_{\text{DRAG}}(\omega_{\text{leakage}}) \ll F_{\text{std}}(\omega_{\text{leakage}})
    \end{equation}

    \item \textbf{Dynamical decoupling}: Engineered spectral notches
    \begin{equation}
    F(\omega_{\text{noise}}) \approx 0 \text{ at targeted frequencies}
    \end{equation}
\end{enumerate}

\textbf{Worked Example: Gaussian Pulse Filter Function}

Consider a Gaussian pulse driving a qubit:
\begin{equation}
\Omega(t) = \Omega_0 \exp\left[-\frac{(t-T/2)^2}{2\sigma^2}\right]
\end{equation}

For a $\pi$-rotation, $\int_0^T \Omega(t)dt = \pi$, giving:
\begin{equation}
\Omega_0 = \frac{\pi}{\sigma\sqrt{2\pi}}
\end{equation}

The control modulation in the rotating frame:
\begin{equation}
y(t) = \Omega(t)\sin(\theta(t))
\end{equation}
where $\theta(t) = \int_0^t \Omega(t')dt'$ is the rotation angle.

For small noise perturbations, $\sin(\theta) \approx \theta$ for early times:
\begin{equation}
y(t) \approx \Omega(t) \cdot \int_0^t \Omega(t')dt'
\end{equation}

The Fourier transform:
\begin{equation}
\tilde{y}(\omega) = \int_0^T y(t)e^{i\omega t}dt
\end{equation}

For $\sigma \ll T$ (well-localized pulse):
\begin{equation}
F(\omega) \approx \frac{\pi^2}{4\sigma^2}\exp[-\sigma^2\omega^2]
\end{equation}

\textbf{Noise infidelity for $1/f$ noise:}
\begin{equation}
\chi_{1/f} = \frac{A\pi^2}{8\pi\sigma^2}\int_{-\infty}^{\infty} \frac{\exp[-\sigma^2\omega^2]}{|\omega|}d\omega
\end{equation}

Using $\int_{-\infty}^{\infty} \frac{e^{-a\omega^2}}{|\omega|}d\omega = \frac{2\sqrt{\pi}}{\sqrt{a}}$:
\begin{equation}
\chi_{1/f} = \frac{A\pi^{3/2}}{4\sigma} = \frac{A\pi^{3/2}}{4}\sqrt{\frac{T_{\text{gate}}}{\ln(T_{\text{gate}}/t_0)}}
\end{equation}

This shows that Gaussian pulses provide $\chi \propto 1/\sqrt{T_{\text{gate}}}$ scaling, better than square pulses' $\chi \propto T_{\text{gate}}$.

\textbf{Noise PSD Overlay Interpretation:}

When plotting filter functions with noise PSDs:
\begin{itemize}
    \item \textbf{Overlap regions}: High $F(\omega) \times S(\omega)$ → dominant noise contribution
    \item \textbf{Spectral holes}: Regions where $F(\omega) \approx 0$ → noise suppression
    \item \textbf{Peak shifts}: Moving $F(\omega)$ peaks away from $S(\omega)$ peaks reduces infidelity
\end{itemize}

\textbf{Optimization Strategy:}
\begin{equation}
\min_{u(t)} \chi = \min_{u(t)} \int F[u](\omega)S(\omega)d\omega
\end{equation}
subject to gate fidelity constraint $F_{\text{gate}} > 1 - \epsilon$.

This is implemented as a weighted cost in optimal control:
\begin{equation}
J[u] = F_{\text{gate}}[u] - \lambda_{\text{noise}}\chi[u]
\end{equation}

\subsubsection{Randomized Benchmarking}

\textbf{Introduction and Motivation:}

Randomized Benchmarking (RB) is a scalable protocol for characterizing the average error rate of a gate set without requiring state tomography or precise state preparation. It provides a hardware-independent measure of gate performance that is robust to state preparation and measurement (SPAM) errors.

\textbf{Clifford Group Algebra and Representation:}

The single-qubit Clifford group $\mathcal{C}_1$ consists of 24 unitary operators that:
\begin{itemize}
    \item Normalize the Pauli group: $C \sigma_j C^\dagger \in \{\pm\sigma_x, \pm\sigma_y, \pm\sigma_z, \pm I\}$
    \item Form a finite group under matrix multiplication
    \item Can be efficiently simulated classically (Gottesman-Knill theorem)
\end{itemize}

\textbf{Generator Construction:}

The Clifford group is generated by two elements:
\begin{align}
H &= \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \quad \text{(Hadamard)} \\
S &= \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix} \quad \text{(Phase gate)}
\end{align}

\textbf{Complete 24-Element Enumeration:}

The group elements can be organized by cosets of the Pauli group:
\begin{equation}
\mathcal{C}_1 = \{I, X, Y, Z\} \times \{I, H, S, HS, SH, HSH\}
\end{equation}

Explicit construction via systematic enumeration:
\begin{itemize}
    \item Identity coset: $\{I, S, S^2, S^3, HS, HS^3\}$ (6 elements)
    \item $H$ coset: $\{H, SH, S^2H, S^3H, HSH, HS^2H\}$ (6 elements)
    \item $X$ coset: $\{X, XS, XS^2, XS^3, XHS, XHS^3\}$ (6 elements)
    \item $Y$ coset: $\{Y, YS, YS^2, YS^3, YHS, YHS^3\}$ (6 elements)
\end{itemize}

Total: $4 \times 6 = 24$ elements (modulo global phase).

\textbf{RB Protocol Description:}

The standard RB experiment proceeds as follows:

\begin{enumerate}
    \item \textbf{Sequence Generation}: For each sequence length $m$, generate $K$ random sequences:
    \begin{itemize}
        \item Sample $m$ Clifford gates uniformly: $C_1, C_2, \ldots, C_m \in \mathcal{C}_1$
        \item Compute the inverse: $C_{\text{inv}} = (C_m \cdots C_2 C_1)^{-1}$
        \item Full sequence: $C_{\text{seq}} = C_{\text{inv}} C_m \cdots C_2 C_1 = I$
    \end{itemize}

    \item \textbf{Execution}: Prepare initial state $\ket{0}$, apply sequence, measure in computational basis

    \item \textbf{Survival Probability}: Average over $K$ sequences at each $m$:
    \begin{equation}
    P_{\text{surv}}(m) = \frac{1}{K}\sum_{k=1}^K P(\text{measure } \ket{0} | \text{sequence } k)
    \end{equation}

    \item \textbf{Fitting}: Extract decay parameter $p$ from exponential fit
\end{enumerate}

\textbf{RB Decay Curve Derivation (Exponential Model):}

Under the assumption of gate-independent, depolarizing noise, the RB decay follows:
\begin{equation}
P_{\text{surv}}(m) = A p^m + B
\end{equation}

\textbf{Derivation:}

For a noisy gate implementation $\tilde{C}$ of ideal Clifford $C$, the error channel is:
\begin{equation}
\mathcal{E}(\rho) = (1-\epsilon) \rho + \epsilon \frac{I}{d}
\end{equation}
where $\epsilon$ is the depolarizing probability and $d=2$ for qubits.

After $m$ gates, the average fidelity decays as:
\begin{equation}
F(m) = (1-\epsilon)^m \approx e^{-m\epsilon} \text{ for small } \epsilon
\end{equation}

The survival probability relates to fidelity via:
\begin{equation}
P_{\text{surv}}(m) = F(m) + \text{SPAM offset}
\end{equation}

Accounting for SPAM errors with asymptotic behavior:
\begin{align}
A &= P(\text{correct prep}) \times P(\text{correct meas}) \\
B &= P(\text{asymptotic depolarized state measured as } \ket{0})
\end{align}

For perfect SPAM: $A = 1$, $B = 1/d = 1/2$ for qubits.

\textbf{Average Gate Fidelity Extraction from Decay Constant:}

The depolarizing parameter $p$ is related to the average gate fidelity by:
\begin{equation}
F_{\text{avg}} = 1 - \frac{(1-p)(d-1)}{d}
\end{equation}

For qubits ($d=2$):
\begin{equation}
F_{\text{avg}} = \frac{1 + p}{2}
\end{equation}

Inverting:
\begin{equation}
p = 2F_{\text{avg}} - 1 = 1 - 2\epsilon
\end{equation}

The average gate infidelity (error rate):
\begin{equation}
r = 1 - F_{\text{avg}} = \frac{1-p}{2}
\end{equation}

\textbf{Interleaved RB Mathematical Framework:}

Interleaved RB characterizes a specific gate $G$ by interleaving it between random Cliffords:
\begin{equation}
\text{Sequence: } C_{\text{inv}} \cdot G \cdot C_m \cdot G \cdot C_{m-1} \cdots G \cdot C_2 \cdot G \cdot C_1
\end{equation}

This produces a decay curve:
\begin{equation}
P_{\text{int}}(m) = A_{\text{int}} p_{\text{int}}^m + B_{\text{int}}
\end{equation}

The gate fidelity is extracted from the ratio:
\begin{equation}
F_G = 1 - \frac{(1 - p_{\text{int}}/p_{\text{std}})(d-1)}{d}
\end{equation}

For qubits:
\begin{equation}
F_G = 1 - \frac{1 - p_{\text{int}}/p_{\text{std}}}{2}
\end{equation}

\textbf{Statistical Analysis and Confidence Intervals:}

The uncertainty in the decay parameter $p$ arises from:
\begin{enumerate}
    \item \textbf{Shot noise}: Finite measurement samples per sequence
    \item \textbf{Sequence sampling}: Finite number of random sequences $K$
    \item \textbf{Fitting uncertainty}: Nonlinear least-squares error propagation
\end{enumerate}

\textbf{Variance from Shot Noise:}

For $N$ measurements per sequence, binomial statistics give:
\begin{equation}
\sigma^2_{P(m)} = \frac{P(m)(1-P(m))}{N}
\end{equation}

\textbf{Variance from Sequence Sampling:}

With $K$ sequences at each $m$:
\begin{equation}
\sigma^2_{\text{seq}}(m) = \frac{\text{Var}[P_k(m)]}{K}
\end{equation}

\textbf{Total Variance:}
\begin{equation}
\sigma^2_{\text{total}}(m) = \sigma^2_{\text{shot}}(m) + \sigma^2_{\text{seq}}(m)
\end{equation}

\textbf{Fitting with Weighted Least Squares:}

Minimize:
\begin{equation}
\chi^2 = \sum_m \frac{[P_{\text{data}}(m) - (Ap^m + B)]^2}{\sigma^2_{\text{total}}(m)}
\end{equation}

\textbf{Confidence Intervals on $p$:}

Using the Jacobian of the fit parameters:
\begin{equation}
\sigma_p^2 = (\mathbf{J}^T \mathbf{W} \mathbf{J})^{-1}_{pp}
\end{equation}
where $\mathbf{W}$ is the weight matrix and $\mathbf{J}$ is the Jacobian.

For exponential decay, the 95\% confidence interval on $p$:
\begin{equation}
p \pm 1.96\sigma_p
\end{equation}

\textbf{Error Propagation to Gate Fidelity:}

Using $F_{\text{avg}} = (1+p)/2$:
\begin{equation}
\sigma_{F_{\text{avg}}} = \frac{1}{2}\sigma_p
\end{equation}

\textbf{Recommended Experimental Parameters:}

\begin{itemize}
    \item Sequence lengths: $m \in \{1, 2, 4, 8, 16, 32, 64, 128, 256\}$ (logarithmic spacing)
    \item Number of sequences: $K \geq 30$ per length (for central limit theorem)
    \item Measurements per sequence: $N \geq 1000$ (shot noise $< 3\%$)
    \item Total experiment: $\sim 10^4$ to $10^5$ gate executions
\end{itemize}

\textbf{Common Pitfalls and Best Practices:}

\begin{itemize}
    \item \textbf{Insufficient sequence lengths}: Need $m_{\max}$ such that $p^{m_{\max}} \approx 0.1$ for good fit
    \item \textbf{Correlated errors}: RB assumes gate-independent errors; coherent errors can violate this
    \item \textbf{SPAM errors}: Can be partially canceled with reference sequences
    \item \textbf{Finite gate set}: Native gate compilation can introduce overhead
\end{itemize}

\subsubsection{Fisher Information}

Quantum Fisher information quantifies parameter estimation precision:
\begin{equation}
F(\theta) = \Tr[\rho L^2]
\end{equation}
where $L$ is the symmetric logarithmic derivative satisfying:
\begin{equation}
\frac{\partial\rho}{\partial\theta} = \frac{1}{2}(L\rho + \rho L)
\end{equation}

\textbf{Cramér-Rao Bound:} The variance of any unbiased estimator satisfies:
\begin{equation}
\text{Var}(\hat{\theta}) \geq \frac{1}{NF(\theta)}
\end{equation}
for $N$ measurements.

\subsection{Implementation Summary}

\textbf{Phase 3 Modules:}
\begin{itemize}
    \item \texttt{src/pulses/drag.py} — DRAG pulse implementation (347 lines)
    \item \texttt{src/pulses/composite.py} — Composite pulse sequences (419 lines)
    \item \texttt{src/pulses/adiabatic.py} — Adiabatic passage techniques (508 lines)
    \item \texttt{src/optimization/gates.py} — Universal gate library (502 lines)
    \item \texttt{src/optimization/compilation.py} — Gate compilation (481 lines)
    \item \texttt{src/optimization/filter\_functions.py} — Filter function analysis (673 lines)
    \item \texttt{src/optimization/benchmarking.py} — Randomized benchmarking (679 lines)
\end{itemize}

\textbf{Test Coverage:}
\begin{itemize}
    \item DRAG pulses: 49 tests
    \item Composite pulses: 40 tests
    \item Adiabatic techniques: 44 tests
    \item Gate optimization: 50 tests
    \item Gate compilation: 45 tests
    \item Filter functions: 42 tests
    \item Randomized benchmarking: 41 tests
    \item \textbf{Total Phase 3 tests: 311} (all passing)
\end{itemize}

\textbf{Documentation:}
\begin{itemize}
    \item \texttt{docs/TASK\_1\_SUMMARY.md} — Advanced pulse shaping
    \item \texttt{docs/TASK\_2\_SUMMARY.md} — Gate library and compilation
    \item \texttt{docs/TASK\_3\_SUMMARY.md} — Robustness and benchmarking
    \item \texttt{examples/task3\_demo.py} — Demonstration script
\end{itemize}

%==============================================================================
\section{Future Work}
%==============================================================================

\subsection{Planned Extensions}

Future development phases will address:

\begin{itemize}
    \item \textbf{Two-Qubit Gates:} CNOT, CZ, iSWAP optimization with entangling Hamiltonians
    \item \textbf{Open System Dynamics:} Lindblad master equation with $T_1$, $T_2$ decoherence
    \item \textbf{Visualization Tools:} Interactive dashboards, Bloch sphere animations
    \item \textbf{GPU Acceleration:} JAX implementation for gradient computations
    \item \textbf{Hardware Integration:} Export to experimental pulse compiler formats
    \item \textbf{Quantum Error Correction:} Logical gate optimization for stabilizer codes
\end{itemize}

Each extension will follow the established pattern: theoretical derivation, implementation with comprehensive testing, and validation against analytical or published results.

%==============================================================================
\section{Conclusion}
%==============================================================================

This document establishes the comprehensive theoretical and computational foundations for the QubitPulseOpt quantum control simulation framework. Phase 1 develops the computational infrastructure, drift Hamiltonian formalism, and control Hamiltonians with analytical validation. Phase 2 implements optimal control algorithms (GRAPE, Krotov) with extensive robustness testing. Phase 3 provides advanced pulse shaping techniques (DRAG, composite pulses, adiabatic passage), universal gate compilation, and comprehensive benchmarking protocols (filter functions, randomized benchmarking, Fisher information).

The framework comprises over 4,500 lines of production code with 450+ unit tests (all passing), extensive documentation, and demonstration scripts. All implementations are validated against analytical results or published literature, ensuring scientific rigor and reproducibility.

This document serves as the authoritative reference for all physics, mathematics, and implementation decisions, and will continue to be updated as new capabilities are added.

%==============================================================================
\section*{References}
\addcontentsline{toc}{section}{References}
%==============================================================================

\begin{enumerate}[label={[\arabic*]}]
    \item M.~A. Nielsen and I.~L. Chuang, \emph{Quantum Computation and Quantum Information}, Cambridge University Press (2010).

    \item J.~Johansson, P.~Nation, and F.~Nori, ``QuTiP: An open-source Python framework for the dynamics of open quantum systems,'' \emph{Computer Physics Communications} \textbf{183}, 1760 (2012).

    \item N.~Khaneja, T.~Reiss, C.~Kehlet, T.~Schulte-Herbr\"uggen, and S.~J. Glaser, ``Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms,'' \emph{Journal of Magnetic Resonance} \textbf{172}, 296 (2005).

    \item D.~M. Reich, M.~Ndong, and C.~P. Koch, ``Monotonically convergent optimization in quantum control using Krotov's method,'' \emph{The Journal of Chemical Physics} \textbf{136}, 104103 (2012).

    \item V.~F. Krotov, \emph{Global Methods in Optimal Control Theory}, Marcel Dekker, New York (1996).

    \item F.~Motzoi, J.~M. Gambetta, P.~Rebentrost, and F.~K. Wilhelm, ``Simple pulses for elimination of leakage in weakly nonlinear qubits,'' \emph{Physical Review Letters} \textbf{103}, 110501 (2009).

    \item J.~M. Gambetta, F.~Motzoi, S.~T. Merkel, and F.~K. Wilhelm, ``Analytic control methods for high-fidelity unitary operations in a weakly nonlinear oscillator,'' \emph{Physical Review A} \textbf{83}, 012308 (2011).

    \item S.~Machnes, U.~Sander, S.~J. Glaser, P.~de Fouquières, A.~Gruslys, S.~Schirmer, and T.~Schulte-Herbr\"uggen, ``Comparing, optimizing, and benchmarking quantum-control algorithms in a unifying programming framework,'' \emph{Physical Review A} \textbf{84}, 022305 (2011).

    \item T.~J. Green, J.~Sastrawan, H.~Uys, and M.~J. Biercuk, ``Arbitrary quantum control of qubits in the presence of universal noise,'' \emph{New Journal of Physics} \textbf{15}, 095004 (2013).

    \item L.~Viola and S.~Lloyd, ``Dynamical suppression of decoherence in two-state quantum systems,'' \emph{Physical Review A} \textbf{58}, 2733 (1998).

    \item E.~Knill et al., ``Randomized benchmarking of quantum gates,'' \emph{Physical Review A} \textbf{77}, 012307 (2008).

    \item E.~Magesan, J.~M. Gambetta, and J.~Emerson, ``Scalable and robust randomized benchmarking of quantum processes,'' \emph{Physical Review Letters} \textbf{109}, 080505 (2012).

    \item E.~Magesan, J.~M. Gambetta, and J.~Emerson, ``Characterizing quantum gates via randomized benchmarking,'' \emph{Physical Review A} \textbf{85}, 042311 (2012).

    \item K.~Bergmann, H.~Theuer, and B.~W. Shore, ``Coherent population transfer among quantum states of atoms and molecules,'' \emph{Reviews of Modern Physics} \textbf{70}, 1003 (1998).

    \item H.~K. Cummins, G.~Llewellyn, and J.~A. Jones, ``Tackling systematic errors in quantum logic gates with composite rotations,'' \emph{Physical Review A} \textbf{67}, 042308 (2003).

    \item M.~H. Levitt, ``Composite pulses,'' \emph{Progress in Nuclear Magnetic Resonance Spectroscopy} \textbf{18}, 61 (1986).

    \item S.~Wimperis, ``Broadband, narrowband, and passband composite pulses for use in advanced NMR experiments,'' \emph{Journal of Magnetic Resonance, Series A} \textbf{109}, 221 (1994).

    \item S.~L. Braunstein and C.~M. Caves, ``Statistical distance and the geometry of quantum states,'' \emph{Physical Review Letters} \textbf{72}, 3439 (1994).

    \item T.~Caneva, T.~Calarco, and S.~Montangero, ``Chopped random-basis quantum optimization,'' \emph{Physical Review A} \textbf{84}, 022326 (2011).

    \item G.~T. Genov, D.~Schraft, N.~V. Vitanov, and T.~Halfmann, ``Arbitrarily accurate pulse sequences for robust dynamical decoupling,'' \emph{Physical Review Letters} \textbf{118}, 133202 (2017).

    \item L.~M.~K. Vandersypen and I.~L. Chuang, ``NMR techniques for quantum control and computation,'' \emph{Reviews of Modern Physics} \textbf{76}, 1037 (2005).

    \item D.~J. Egger and F.~K. Wilhelm, ``Adaptive hybrid optimal quantum control for imprecisely characterized systems,'' \emph{Physical Review Letters} \textbf{112}, 240503 (2014).

    \item C.~Zu, W.-B. Wang, L.~He, W.-G. Zhang, C.-Y. Dai, F.~Wang, and L.-M. Duan, ``Experimental realization of universal geometric quantum gates with solid-state spins,'' \emph{Nature} \textbf{514}, 72 (2014).

    \item J.~Kelly et al., ``Optimal quantum control using randomized benchmarking,'' \emph{Physical Review Letters} \textbf{112}, 240504 (2014).
\end{enumerate}

%==============================================================================
\appendix
\section{Appendix: QuTiP API Reference}
\label{app:qutip}
%==============================================================================

For reference, we summarize key QuTiP 5.x API functions used in this project:

\begin{itemize}
    \item \texttt{qt.basis(N, k)} — Returns $\ket{k}$ in $N$-dimensional Hilbert space (e.g., \texttt{qt.basis(2, 0)} = $\ket{0}$).
    \item \texttt{qt.sigmax()}, \texttt{qt.sigmay()}, \texttt{qt.sigmaz()} — Pauli matrices as \texttt{Qobj}.
    \item \texttt{qt.qeye(N)} — Identity operator on $\CC^N$.
    \item \texttt{qt.sesolve(H, psi0, tlist, e\_ops=[])} — Schrödinger equation solver. Returns \texttt{Result} with \texttt{.states} (list of states) and \texttt{.expect} (expectation values if \texttt{e\_ops} provided).
    \item \texttt{qt.expect(op, state)} — Compute $\bra{\psi} \hat{O} \ket{\psi}$.
    \item \texttt{qt.fidelity(psi1, psi2)} — State fidelity $|\braket{\psi_1}{\psi_2}|^2$.
    \item \texttt{qt.Bloch()} — Bloch sphere plotting. Methods: \texttt{.add\_states(states)}, \texttt{.add\_points([x, y, z], meth='l')}, \texttt{.show()}.
\end{itemize}

All QuTiP functions preserve quantum object types (\texttt{Qobj}) and automatically validate dimensions, Hermiticity, and normalization.

\end{document}
